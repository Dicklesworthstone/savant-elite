{"id":"savant_elite_rust-0ac","title":"BEAD-109: Keyboard report normalization edge-case unit tests","description":"# What / why\n\n`savant monitor` reads keyboard-style HID reports and tries to interpret what the pedal is sending.\n\nIn practice, HID backends sometimes vary the raw report framing:\n- some include a leading report-id byte (often 0)\n- some pad reports to a larger endpoint size\n\n`usb_hid::normalize_boot_keyboard_report(data)` normalizes these variants to the canonical 8-byte boot keyboard report.\n\nThis bead adds edge-case tests so we don’t regress normalization logic.\n\n# Scope\n\nUnit tests should cover:\n- input shorter than 8 bytes returns `None`\n- exactly 8 bytes returns that exact report\n- all zeros returns all zeros\n- a “max keys pressed” style report returns unchanged\n\n# Acceptance criteria\n\n- Tests are deterministic and do not require hardware.\n- Tests fail if normalize logic starts accepting too-short data or corrupting the canonical report.\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:44:21.330818-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:51:08.756113-05:00","closed_at":"2026-01-25T20:55:12.296053-05:00","close_reason":"Added missing normalize_boot_keyboard_report edge-case unit tests (too-short input, all-zeros report, all-keys-pressed) and made the existing exact-8-byte case explicit.","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-0ac","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.705682-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-1pa","title":"PLAN: Savant Elite bug fixes, tests, hardening","description":"# Purpose / why this exists\n\nThis bead is the **single source of truth** for the original `BEADS.md` plan.\n\nGoal: keep the project runnable, safe, and maintainable by capturing *all* intended work as beads with explicit dependencies and test coverage, so future work does **not** require consulting `BEADS.md` (or reconstructing context from commits).\n\nThis plan is written for a “future self” coming back cold:\n- what the tool does\n- what can go wrong (user-impacting failure modes)\n- what we chose to harden and why\n- how we test it (unit/integration/manual)\n\n# Project context (quick refresher)\n\n`savant-elite` is a native macOS CLI (`savant`) for programming a discontinued Kinesis Savant Elite USB foot pedal.\n\nHardware behavior that drives the architecture:\n- The device has a physical **Play / Program** switch.\n- Each mode presents a different USB PID.\n- Programming writes permanent mappings to device EEPROM via HID-class control transfers.\n\nSoftware architecture (high level):\n- **CLI layer**: clap parsing + friendly UX output.\n- **Key parsing**: parse strings like `cmd+shift+c` → (modifier byte, HID keycode).\n- **Device access**:\n  - Play mode: enumerate and read input via `hidapi`.\n  - Program mode: send programming commands via `rusb`/libusb.\n- **Local config file**: stores last programmed mapping so `savant info` can visualize configuration even though the device EEPROM is write-only.\n\n# Over-arching goals for this plan\n\n1. **Fail fast on user input** (clear errors, no cryptic messages).\n2. **Make device programming safe** (avoid silent truncation, handle disconnects, best-effort verification).\n3. **Make behavior testable**:\n   - pure parsing + serialization covered by unit tests\n   - clap validation + CLI parsing covered by integration tests\n   - hardware flows captured in manual scripts with *detailed logging*\n4. **Keep CI signal high**: no spurious warnings, tests are deterministic (no hardware required).\n\n# Testing strategy (what to run and when)\n\nAutomated:\n- `cargo test` runs:\n  - unit tests in `src/main.rs` (pure logic)\n  - integration tests in `tests/cli_validation.rs` (CLI argument validation)\n\nManual (hardware required; not run in CI):\n- `tests/e2e_hardware_sim.sh` (guided + logged)\n- `tests/e2e_config.sh` (safe backup/restore + format checks + optional manual verification)\n\nLogs:\n- Manual scripts should create timestamped logs under `tests/logs/`.\n- Log output should include command lines, timestamps, and any manual-check prompts.\n\n# Bead map (the actual work)\n\nPhase 1 — Critical bug fixes (input validation + safety)\n- BEAD-001: KeyAction input validation (empty/plus edge cases) + tests (BEAD-101/102)\n- BEAD-002: Config file newline injection protection + tests (BEAD-103)\n- BEAD-003: Auto-monitor wait loop timeout/reminders (hardware-only validation)\n- BEAD-004: raw-cmd data length truncation fix + coverage (BEAD-104)\n- BEAD-005: clap validation for `--interface` + coverage (BEAD-105)\n- BEAD-006: persist config even on partial programming success + coverage (BEAD-106)\n- BEAD-007: add error context for kernel driver detach\n\nPhase 2 — Hardening (device safety + protocol robustness)\n- BEAD-020: detect USB disconnects mid-program + improve messaging\n- BEAD-021: best-effort read-back verification with GET_KEY_MACRO\n- BEAD-022: HidApi lifecycle cleanup\n- BEAD-023: eliminate HID magic numbers via usb_constants\n\nPhase 3 — Unit tests (parsing coverage)\n- BEAD-107: HID keycode table coverage\n- BEAD-108: modifier alias/combo parsing coverage\n- BEAD-109: boot keyboard report normalization edge cases\n\nPhase 4 — Integration/E2E\n- BEAD-201: CLI validation integration tests (no hardware)\n- BEAD-202: manual hardware test script with detailed logging\n- BEAD-203: manual config persistence script with detailed logging\n\nPhase 5 — Infra/docs\n- BEAD-301: dev-deps for tests\n- BEAD-302: tests/ docs + script scaffolding\n- BEAD-303: CI updates to run tests cleanly\n- BEAD-304: top-level TESTING.md\n\n# Dependency rules (how the graph should read)\n\n- Tests should depend on the functionality they validate (use dependency type `validates` when appropriate).\n- Infra/docs beads should depend on prerequisites (e.g., CI depends on tests existing).\n- Avoid cycles; `bd dep cycles` must remain empty.\n\n# Canonical docs\n\n- `README.md` — user-facing docs + protocol overview\n- `TESTING.md` — contributor/operator test entrypoint\n- `tests/README.md` — details on manual scripts\n\n","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-25T23:45:02.449968-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:45:11.364622-05:00","closed_at":"2026-01-25T23:45:11.364622-05:00","close_reason":"Plan captured in a single canonical epic for future reference; implementation beads are tracked in BEAD-* issues.","labels":["docs","meta","plan"]}
{"id":"savant_elite_rust-1rd","title":"BEAD-023: Add USB constants module","description":"# What / why\n\nThe programming logic relies on low-level USB/HID control transfers.\n\nBefore this bead, several “magic numbers” were scattered across the codebase:\n- request types (`0x21`, `0xA1`, `0x40`)\n- requests (`SET_REPORT = 0x09`, `GET_REPORT = 0x01`)\n- report-type bases (`0x0100`, `0x0200`, `0x0300`)\n\nThese values are semantically meaningful; leaving them inline makes the code harder to audit and easier to get subtly wrong.\n\n# Scope\n\n- Introduce a `usb_constants` module that names the key HID/USB constants we use.\n- Replace inline numeric literals in the programming + readback paths.\n\nOut of scope:\n- large refactors into multiple files/modules (we keep changes minimal)\n\n# Design / approach\n\nAdd a small module with descriptive constants:\n\n- HID class/interface request types:\n  - host→device class/interface (`0x21`)\n  - device→host class/interface (`0xA1`)\n- HID bRequest values:\n  - `SET_REPORT` (`0x09`)\n  - `GET_REPORT` (`0x01`)\n- HID report-type bases for wValue:\n  - input (`0x0100`)\n  - output (`0x0200`)\n  - feature (`0x0300`)\n- Vendor request type used by the alternate programming method (`0x40`)\n\nThen update call sites:\n- `handle.write_control(...)` in programming for SET_KEY_MACRO and SAVE_TO_EEPROM\n- `handle.read_control(...)` in `verify_pedal_programming()`\n\n# Testing\n\nNo tests added:\n- this is a refactor for readability and auditability\n- behavior is covered by existing unit/integration tests + manual hardware scripts\n\n# Acceptance criteria\n\n- No remaining inline HID request/report magic numbers in the core programming + verification paths.\n- Code reads like “HID_SET_REPORT” rather than “0x09”.\n\n","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T20:44:29.625592-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:38.950297-05:00","closed_at":"2026-01-25T20:55:21.835262-05:00","close_reason":"Added usb_constants module and replaced HID control-transfer magic numbers (request types, SET/GET_REPORT, report-type bases) in programming/readback paths.","labels":["cleanup","hardening","phase2"],"dependencies":[{"issue_id":"savant_elite_rust-1rd","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.225735-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-27p","title":"BEAD-102: Unit tests for KeyAction malformed plus handling","description":"# What / why\n\nThis bead adds unit tests that lock in BEAD-001’s handling of malformed `+` separators.\n\nThese are important because they’re easy for users to type accidentally, and the resulting errors should be self-explanatory.\n\n# Scope\n\nUnit tests should cover:\n- leading plus: `+c`\n- trailing plus: `cmd+`\n- only plus: `+`\n- consecutive plus: `cmd++c`\n\nOptionally (covered by integration tests, but unit tests are fine too):\n- whitespace variants like `cmd+ +c` (empty component after trimming)\n\n# Test design\n\nAssertions should:\n- ensure an error occurs\n- confirm the error message indicates the underlying issue (start/end plus, empty component, consecutive plus)\n\n# Acceptance criteria\n\n- All malformed forms above return errors.\n- Valid forms remain valid.\n\n# Related beads\n\n- Validates: BEAD-001\n\n","status":"closed","priority":1,"issue_type":"task","estimated_minutes":30,"created_at":"2026-01-25T18:52:49.218888-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:57.183-05:00","closed_at":"2026-01-25T18:54:24.607101-05:00","close_reason":"Tests added in same commit as BEAD-001 fix","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-27p","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.346154-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-27p","depends_on_id":"savant_elite_rust-4eo","type":"validates","created_at":"2026-01-25T23:54:02.870356-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-34w","title":"BEAD-007: Missing error context for kernel driver detach","description":"# What / why\n\nWhen programming in USB “PROGRAM” mode via `rusb`/libusb, we may need to detach the kernel driver from an interface before claiming it.\n\nIf `detach_kernel_driver()` fails, the raw error from libusb is often not actionable for end users.\n\nThis bead improves UX by adding context that points users to the most common fix on macOS:\n- run with `sudo`\n\n# Scope\n\n- Wrap the `detach_kernel_driver(interface_num)` call with `anyhow::Context`.\n\nOut of scope:\n- changing when/how we detach\n\n# Design / approach\n\nUse `.context(\"Failed to detach kernel driver - try running with sudo\")` on the detach call so that:\n- the original error is preserved\n- users see immediate next steps\n\n# Testing\n\nNo automated tests:\n- this is an OS/hardware-specific failure path\n\nManual validation:\n- run `savant program` without sufficient privileges and confirm the error message includes the added context.\n\n# Acceptance criteria\n\n- When kernel detach fails, the error surfaced to the user includes “try running with sudo”.\n\n","status":"closed","priority":3,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":5,"created_at":"2026-01-25T18:52:37.323221-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:48:12.550533-05:00","closed_at":"2026-01-25T18:57:29.236818-05:00","close_reason":"Fixed: Added .context() for kernel driver detach error","labels":["error-handling","low","phase1"],"dependencies":[{"issue_id":"savant_elite_rust-34w","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.376901-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-3cr","title":"BEAD-203: E2E config-file persistence test script","description":"# What / why\n\n`savant` uses a local config file to remember the last programmed mapping for display and retry purposes.\n\nWe want a safe, repeatable manual script that verifies config-file handling without risking permanent changes:\n- back up any existing user config\n- write a known-good config\n- perform simple format checks\n- restore the user’s config on exit\n\nThis also acts as a “future self” sanity tool when changing config parsing/serialization.\n\n# Scope\n\nAdd a manual script:\n- `tests/e2e_config.sh`\n\nScript requirements:\n- determine config base path correctly:\n  - macOS: `~/Library/Application Support`\n  - otherwise: `$XDG_CONFIG_HOME` or `~/.config`\n- back up existing `pedals.conf` to a timestamped backup under `tests/logs/`\n- write a known-good config (`cmd+c`, `cmd+a`, `cmd+v`)\n- validate the format (presence of `left=`, `middle=`, `right=`)\n- restore previous config on exit (trap)\n\n# Logging requirements\n\n- write a timestamped log under `tests/logs/`\n- log the commands executed and high-level outcomes\n\n# Acceptance criteria\n\n- Script never permanently clobbers user config; it restores on exit.\n- Format checks are explicit and logged.\n- Script provides optional manual verification instructions for `savant info` visualization.\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:44:38.506772-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:51:52.999527-05:00","closed_at":"2026-01-25T20:55:29.869426-05:00","close_reason":"Added tests/e2e_config.sh: safe config-file script with backup/restore, basic format checks, and macOS-aware config path.","labels":["e2e","phase4","test"],"dependencies":[{"issue_id":"savant_elite_rust-3cr","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.602836-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-3cr","depends_on_id":"savant_elite_rust-yma","type":"blocks","created_at":"2026-01-25T23:54:03.420879-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-4eo","title":"BEAD-001: Empty/malformed key action input validation","description":"# What / why\n\n`KeyAction::from_string()` is the single parser for user-facing key-action strings like `cmd+c` or `ctrl+shift+f12`. This parser is hit by:\n- `savant program --left/--middle/--right ...`\n- any future feature that accepts key-action strings\n\nBefore this bead, malformed inputs produced **confusing, low-signal errors**:\n- `\"\"` → `Unknown key: \"\"` (looks like an internal bug)\n- `\"+\"` → split into empty tokens → `Unknown modifier: \"\"`\n- `\"shift+\"` → `Unknown key: \"\"`\n\nThis is a UX footgun: users don’t know what they did wrong, and the fix (“don’t start/end with `+` / don’t leave it blank”) is easy.\n\n# Scope\n\nTighten parsing validation for the following classes of invalid input:\n\n1. **Empty / whitespace-only**: `\"\"`, `\"   \"`\n2. **Leading or trailing plus**: `\"+c\"`, `\"cmd+\"`\n3. **Consecutive plus / empty component**: `\"cmd++c\"` and variants like `\"cmd + + c\"`\n\nOut of scope:\n- supporting multi-key macros (hardware limitation)\n- adding new key names (handled by `usb_hid::parse_key_name`)\n\n# Design / approach\n\nValidation should happen **before** any device operations so:\n- CLI arg validation works even when no hardware is connected\n- errors are deterministic and testable\n\nImplementation rules:\n- `trim()` the full string first\n- reject empty input early with a direct error (no “Unknown …”)\n- reject leading/trailing `+` (these always imply empty token)\n- reject `\"++\"` as a fast-path; also reject any token that becomes empty after trimming (covers `\"cmd + + c\"`)\n- keep the “last token is key; prior tokens are modifiers” contract\n\n# Testing\n\nCovered by unit tests:\n- BEAD-101: empty + whitespace-only input\n- BEAD-102: malformed plus cases (leading/trailing/only-plus/double-plus)\n\nAlso implicitly validated by CLI integration tests in BEAD-201 (because `program --dry-run` parses actions before touching hardware).\n\n# Acceptance criteria\n\n- `KeyAction::from_string(\"\")` and `KeyAction::from_string(\"   \")` return an error that mentions **cannot be empty**.\n- `KeyAction::from_string(\"+c\")`, `KeyAction::from_string(\"cmd+\")`, `KeyAction::from_string(\"+\")` return an error that mentions **cannot start or end with '+'**.\n- `KeyAction::from_string(\"cmd++c\")` returns an error that clearly indicates an **empty modifier / consecutive '+'**.\n- Valid inputs remain valid and unchanged (`cmd+c`, `ctrl+shift+alt+f12`, etc.).\n\n# Related beads\n\n- Validated by: BEAD-101, BEAD-102\n- Feeds into: BEAD-020 (disconnect hardening relies on robust early validation)\n\n","status":"closed","priority":0,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":30,"created_at":"2026-01-25T18:52:12.47601-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:46:20.477883-05:00","closed_at":"2026-01-25T18:54:24.510782-05:00","close_reason":"Fixed: Added input validation for empty, whitespace, leading/trailing +, and consecutive +","labels":["critical","input-validation","phase1"],"dependencies":[{"issue_id":"savant_elite_rust-4eo","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:40.990985-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-51c","title":"BEAD-303: Update CI to run integration tests","description":"# What / why\n\nCI should provide high-signal feedback that the project is healthy:\n- unit tests (pure logic)\n- integration tests (CLI behavior)\n\nBecause this is a macOS-only project, CI should run on macOS runners.\n\n# Scope\n\nUpdate `.github/workflows/ci.yml` so CI:\n- runs `cargo test`\n- makes integration test output easy to spot (separate step/job is fine)\n- does not attempt hardware-dependent scripts\n\n# Acceptance criteria\n\n- CI runs on macOS and passes with:\n  - unit tests in `src/main.rs`\n  - integration tests in `tests/cli_validation.rs`\n- CI output is readable (failures clearly attributed to unit vs integration).\n\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T20:34:26.881343-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:52:17.676566-05:00","closed_at":"2026-01-25T20:35:49.752112-05:00","close_reason":"CI workflow updated to split test steps: unit tests (21) and E2E CLI tests (33) now run separately for clearer output","labels":["ci","infra","phase5"],"dependencies":[{"issue_id":"savant_elite_rust-51c","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.044593-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-51c","depends_on_id":"savant_elite_rust-qvt","type":"blocks","created_at":"2026-01-25T23:54:03.519638-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-51c","depends_on_id":"savant_elite_rust-wyy","type":"blocks","created_at":"2026-01-25T23:54:03.567342-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-5iu","title":"BEAD-005: Negative interface number accepted","description":"# What / why\n\n`raw-cmd` accepts `--interface` to select a specific HID interface number.\n\nUSB/HID interface numbers are inherently non-negative and practically fit in a byte (`u8`).\n\nBefore this bead, clap parsed `--interface` as `i32` with no range validation. That allowed nonsense inputs like `--interface -1`.\n\nEven though a negative interface is unlikely to do damage (it won’t match any real interface), it creates unnecessary confusion:\n- users don’t get immediate feedback that the input is invalid\n- future refactors could accidentally cast and mis-handle negative values\n\n# Scope\n\n- Add clap-level range validation for `--interface` to restrict it to `[0, 255]`.\n\nOut of scope:\n- changing how interfaces are discovered\n\n# Design / approach\n\nUse clap’s `value_parser` range constraint:\n\n```rust\n#[arg(long, default_value = \"0\", value_parser = clap::value_parser!(i32).range(0..=255))]\ninterface: i32,\n```\n\nThis ensures invalid values never reach runtime logic.\n\n# Testing\n\nBecause this is a clap-level validation, it is best tested via CLI integration tests rather than unit tests:\n- BEAD-105 exists to record this intent.\n- BEAD-201 includes the actual assertions:\n  - negative interface rejected\n  - interface \u003e 255 rejected\n\n# Acceptance criteria\n\n- `savant raw-cmd --cmd b5 --interface -1` fails argument parsing.\n- `savant raw-cmd --cmd b5 --interface 256` fails argument parsing.\n- Values 0..=255 remain accepted.\n\n# Related beads\n\n- Validated by: BEAD-105 and BEAD-201\n\n","status":"closed","priority":3,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":10,"created_at":"2026-01-25T18:52:37.205971-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:47:30.369261-05:00","closed_at":"2026-01-25T18:57:29.185998-05:00","close_reason":"Fixed: Added clap value_parser range(0..=255) for interface number","labels":["input-validation","low","phase1"],"dependencies":[{"issue_id":"savant_elite_rust-5iu","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.427553-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-6hu","title":"BEAD-004: Raw command data silently truncated","description":"# What / why\n\n`raw-cmd` is an expert-only escape hatch that lets us send arbitrary HID output reports for reverse engineering / debugging.\n\nInternally, we construct a fixed-size 36-byte buffer:\n- byte 0: report id (0)\n- byte 1: command byte\n- bytes 2..=35: payload bytes (max 34 bytes)\n\nBefore this bead, if the user provided more than 34 data bytes, we silently dropped the excess due to a bounds check in the copy loop.\n\nThis is dangerous even for “expert mode”:\n- it makes troubleshooting impossible (“why didn’t the device respond?”)\n- it hides mistakes (off-by-one, wrong protocol format)\n- it violates the principle “never silently truncate user input”\n\n# Scope\n\n- Add an explicit validation for raw data length.\n- If payload length exceeds 34 bytes, return an error describing:\n  - the provided length\n  - the maximum allowed length\n\nOut of scope:\n- changing the raw-cmd wire format or buffer size\n\n# Design / approach\n\nImplement a single source of truth:\n\n- Define `MAX_RAW_DATA_LEN: usize = 34` (because 36 total bytes minus report-id + cmd).\n- Validate `data_bytes.len() \u003c= MAX_RAW_DATA_LEN` before constructing the buffer.\n- Keep the copy loop as a defensive fallback, but it should never truncate anymore because the earlier check prevents it.\n\nImplementation reference: `SavantElite::raw_cmd` in `src/main.rs`.\n\n# Testing\n\n- Primary coverage is via integration tests (BEAD-201):\n  - `cli_raw_cmd_rejects_data_too_long` ensures clap+runtime rejects overlong payloads and keeps behavior stable.\n\nWe intentionally avoided a separate unit-level refactor just for this check (see BEAD-104).\n\n# Acceptance criteria\n\n- `savant raw-cmd --cmd b5 --data \u003chex\u003e` fails when decoded payload length \u003e 34.\n- Error message indicates the actual vs max sizes.\n- Valid inputs (≤ 34 bytes) behave the same as before.\n\n# Related beads\n\n- Validated by: BEAD-104 (decision recorded) + BEAD-201 (integration test)\n\n","status":"closed","priority":2,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":15,"created_at":"2026-01-25T18:52:37.14068-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:47:18.594686-05:00","closed_at":"2026-01-25T18:55:55.183355-05:00","close_reason":"Fixed: Added MAX_RAW_DATA_LEN validation (34 bytes) with clear error message","labels":["input-validation","medium","phase1"],"dependencies":[{"issue_id":"savant_elite_rust-6hu","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.072349-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-70s","title":"BEAD-107: Unit tests for USB HID key code coverage","description":"# What / why\n\n`usb_hid::parse_key_name()` is the lookup table from user-facing key strings (e.g. `\"a\"`, `\"f12\"`, `\"enter\"`) to HID keycodes.\n\nA single wrong mapping produces confusing user outcomes:\n- the pedal is programmed successfully but sends the wrong key\n- the user blames hardware or the tool\n\nSo we want broad table-coverage tests that catch accidental regressions.\n\n# Scope\n\nUnit tests should cover:\n- all letters a–z map to 0x04–0x1D\n- numbers 1–9 map to 0x1E–0x26 and 0 maps to 0x27\n- function keys f1–f12 map to 0x3A–0x45\n- case-insensitivity (`A` == `a`, `F12` == `f12`, etc.)\n\nAdditionally (useful guardrails):\n- common aliases (`enter`/`return`, `esc`/`escape`)\n- arrow keys\n- unknown keys return `None`\n\n# Test design\n\nPrefer loops for systematic coverage (reduces copy/paste mistakes), and include helpful assertion messages so failures pinpoint the broken mapping.\n\n# Acceptance criteria\n\n- Tests pass and cover the primary key families (letters/numbers/F-keys).\n- Tests fail if any mapping is changed accidentally.\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:34:33.432343-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:49.320608-05:00","closed_at":"2026-01-25T20:36:59.261142-05:00","close_reason":"Added 7 comprehensive unit tests for USB HID key code parsing: all letters, numbers, function keys, special keys, arrow keys, case insensitivity, and unknown key handling","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-70s","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.809421-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-7h5","title":"BEAD-020: Add USB disconnect detection during programming","description":"# What / why\n\nProgramming the Savant Elite is a multi-step USB operation:\n1. For each pedal (left/middle/right), send a `CMD_SET_KEY_MACRO` command.\n2. Send `CMD_SAVE_TO_EEPROM` to persist changes.\n\nA critical real-world failure mode is **USB disconnect mid-program**:\n- user accidentally unplugs the device\n- USB hub blips\n- macOS suspends/re-enumerates\n\nWithout explicit detection, the tool can:\n- emit confusing pipe/timeout errors\n- continue trying further commands\n- leave the user unsure what actually happened\n\nAlso, the hardware behavior matters:\n- SET_KEY_MACRO changes may be staged in RAM.\n- If the device is unplugged before EEPROM save, those changes are typically lost.\n\nSo the tool must handle disconnects explicitly and communicate the consequences clearly.\n\n# Scope\n\n- Detect device disappearance during the programming sequence.\n- Print a clear warning and next steps when it happens.\n- Do **not** continue sending further commands after a disconnect is detected.\n\nOut of scope:\n- guaranteeing atomic programming at the hardware level (the device protocol doesn’t provide it)\n\n# Design / approach\n\nKey idea: treat “device presence” as a first-class invariant while programming.\n\nImplementation sketch:\n- Record the device’s bus number + address at the start of programming.\n- After each pedal (and again before EEPROM save), check if the same bus/address is still present in `rusb::devices()`.\n  - If not present, assume disconnect/re-enumeration and abort.\n\nUX behaviors:\n- Before starting, print an explicit warning: keep device connected.\n- On detected disconnect:\n  - show a prominent warning box\n  - explain that pedal settings were only in RAM and were lost\n  - instruct the user to reconnect in PROGRAM mode and rerun `savant program`\n\nImportant nuance:\n- In a disconnect-abort path, do **not** write the local config file (because we explicitly tell the user the changes were lost).\n\n# Testing\n\nAutomated tests are not appropriate here because:\n- detection depends on real USB enumeration state\n- reproducing disconnect reliably in CI isn’t feasible\n\nManual validation:\n- Use `tests/e2e_hardware_sim.sh` (BEAD-202) for the normal program/monitor happy path.\n- Optional (risky) manual test: unplug during programming to confirm messaging. This should be clearly marked as potentially leaving the device in an unexpected state.\n\n# Acceptance criteria\n\n- If the device disappears during programming:\n  - the tool stops further programming immediately\n  - the user sees a clear “DEVICE DISCONNECTED” message\n  - the tool explains that changes were not saved to EEPROM and were lost\n  - the tool prints the exact next steps to recover\n\n","status":"closed","priority":1,"issue_type":"feature","assignee":"claude-opus-4.5","estimated_minutes":60,"created_at":"2026-01-25T18:53:04.082412-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:48:33.020451-05:00","closed_at":"2026-01-25T19:35:43.314684-05:00","close_reason":"Implemented USB disconnect detection: added pre-programming warning, device presence check after each pedal, and enhanced error messages for partial programming state","labels":["hardening","phase2"],"dependencies":[{"issue_id":"savant_elite_rust-7h5","depends_on_id":"savant_elite_rust-4eo","type":"blocks","created_at":"2026-01-25T18:53:04.086585-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-7h5","depends_on_id":"savant_elite_rust-bq1","type":"blocks","created_at":"2026-01-25T18:53:04.087526-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-7h5","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.197667-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-7sc","title":"BEAD-104: Unit tests for raw command data length validation","description":"# What / why\n\nOriginal plan intent:\n- Add a unit test that ensures raw-cmd rejects payloads \u003e 34 bytes (the fix in BEAD-004).\n\nDuring implementation we made a deliberate choice:\n- The validation is a simple length check.\n- We already have CLI integration tests (BEAD-201) that exercise the real command-line behavior.\n- Refactoring `raw_cmd` solely to expose a “unit-testable helper” would add code surface and complexity with minimal benefit.\n\nSo this bead acts as a **design record**: we consider BEAD-004’s behavior validated by integration tests.\n\n# Scope\n\n- Ensure there is durable test coverage that overlong raw-cmd payloads are rejected.\n\n# Where it is covered\n\n- BEAD-201 integration test:\n  - `cli_raw_cmd_rejects_data_too_long`\n\n# When to revisit\n\nConsider adding a true unit test if:\n- `raw_cmd` validation logic becomes more complex than a simple length check\n- we introduce additional raw command formats/parsing where unit tests provide better granularity\n\n","status":"closed","priority":2,"issue_type":"task","estimated_minutes":20,"created_at":"2026-01-25T18:52:49.344287-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:19.023492-05:00","closed_at":"2026-01-25T18:55:55.228348-05:00","close_reason":"Validation logic simple enough; covered by integration test BEAD-201","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-7sc","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.967191-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-7sc","depends_on_id":"savant_elite_rust-6hu","type":"validates","created_at":"2026-01-25T23:54:03.054339-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-83m","title":"BEAD-101: Unit tests for KeyAction empty string handling","description":"# What / why\n\nThis bead adds unit tests that lock in the desired UX for BEAD-001:\n- empty or whitespace-only key-action strings should produce a clear “cannot be empty” error.\n\nWe keep these as unit tests because:\n- they’re pure parsing logic (no hardware, deterministic)\n- they enforce error-message clarity at the source\n\n# Scope\n\nAdd unit tests for:\n- `KeyAction::from_string(\"\")`\n- `KeyAction::from_string(\"   \")`\n\n# Test design\n\nAssertions should:\n- ensure an error occurs\n- verify the error message contains a stable phrase (e.g., “cannot be empty”)\n\nAvoid overfitting to exact punctuation so small copy changes don’t cause churn.\n\n# Acceptance criteria\n\n- Tests pass on all platforms (no hardware requirements).\n- Error message contains “cannot be empty” (case-sensitive is fine as long as stable).\n\n# Related beads\n\n- Validates: BEAD-001\n\n","status":"closed","priority":1,"issue_type":"task","estimated_minutes":30,"created_at":"2026-01-25T18:52:49.154301-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:48.731759-05:00","closed_at":"2026-01-25T18:54:24.561159-05:00","close_reason":"Tests added in same commit as BEAD-001 fix","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-83m","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.397774-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-83m","depends_on_id":"savant_elite_rust-4eo","type":"validates","created_at":"2026-01-25T23:54:02.777809-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-9dr","title":"BEAD-202: E2E hardware test script (manual)","description":"# What / why\n\nSome critical behaviors cannot be validated in CI because they require real hardware:\n- device detection across Play vs Program modes\n- actual EEPROM programming\n- monitor output correctness\n\nTo make manual verification repeatable and auditable, we want a guided script that:\n- runs the right commands in the right order\n- prompts for the required physical switch/replug steps\n- produces a timestamped log artifact\n\n# Scope\n\nAdd a manual E2E script:\n- `tests/e2e_hardware_sim.sh`\n\nThe script should:\n- build `target/release/savant` if missing\n- write logs to `tests/logs/` (timestamped filename)\n- run a baseline set of commands that don’t require hardware\n- guide the user through connecting hardware and switching modes\n\n# Logging requirements\n\nLogs should be self-explanatory:\n- include timestamps\n- include the exact command line executed\n- capture stdout/stderr\n- include “manual check” prompts where a human must verify behavior\n\n# Safety / user considerations\n\n- “Real programming” writes to EEPROM; script should explicitly prompt before doing it.\n- `savant program` may require `sudo` on macOS.\n- `savant monitor` requires Input Monitoring permission for the terminal.\n\n# Acceptance criteria\n\n- Running `tests/e2e_hardware_sim.sh` produces a log file under `tests/logs/`.\n- The script guides a full happy-path flow: Play → Program → program → Play → monitor.\n- The script is safe-by-default (explicit prompt before real programming).\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:44:34.303495-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:51:34.603309-05:00","closed_at":"2026-01-25T20:55:25.983352-05:00","close_reason":"Added tests/e2e_hardware_sim.sh: guided, logged manual hardware verification flow for status/info/program/monitor.","labels":["e2e","manual","phase4","test"],"dependencies":[{"issue_id":"savant_elite_rust-9dr","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.654298-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-9dr","depends_on_id":"savant_elite_rust-yyo","type":"blocks","created_at":"2026-01-25T23:54:03.37605-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-9fm","title":"BEAD-003: Auto-monitor infinite wait loop with no timeout","description":"# What / why\n\n`savant program` has an optional `--monitor` flow that helps the user immediately test their newly programmed mappings.\n\nThe hardware reality:\n- To program, the device must be in **PROGRAM** mode (different PID).\n- To *monitor key output*, the device must be in **PLAY** mode.\n- Switching modes requires flipping a physical switch and replugging.\n\nBefore this bead, the auto-monitor handoff waited in a tight loop for the play-mode HID interface with **no timeout**. If the user forgot to flip the switch, the program appeared “hung” forever.\n\nThis is a UX failure mode:\n- users don’t know if the tool is stuck or if they did something wrong\n- you lose the “trust moment” right after programming\n\n# Scope\n\n- Add a **hard timeout** (default: 60s) for the “waiting for play mode” loop.\n- Print periodic reminders while waiting.\n- On timeout, exit the auto-monitor path gracefully with actionable instructions.\n\nOut of scope:\n- fully automating mode switching (hardware switch prevents it)\n\n# Design / approach\n\nImplement a user-friendly wait loop:\n- Track `wait_start` and `timeout`.\n- Sleep in small increments (e.g., 500ms) and retry opening the keyboard interface.\n- Print a reminder every ~10s with remaining seconds.\n- If the timeout is exceeded:\n  - print a clear timeout message\n  - instruct the user to run `savant monitor` manually after switching modes\n  - return `Ok(())` so the user isn’t stuck with an “error” for a normal human mistake\n\nImplementation reference: `src/main.rs` auto-monitor wait loop near the `--monitor` path (look for “Timeout! Device not detected …”).\n\n# Testing\n\nAutomated tests are intentionally **not** added here:\n- the behavior depends on real HID device availability and wall-clock time.\n\nValidation should be done via the manual hardware script:\n- BEAD-202 (`tests/e2e_hardware_sim.sh`) can be used to simulate “never switch back to Play mode” and confirm:\n  - reminders print\n  - timeout triggers\n  - program exits without hanging\n\n# Acceptance criteria\n\n- If `--monitor` is requested and the device never appears in Play mode, the CLI prints:\n  - periodic “still waiting” reminders\n  - a timeout message after 60 seconds\n  - a clear next step (“run `savant monitor` manually after switching modes”)\n- The CLI does not hang indefinitely.\n\n# Related beads\n\n- Complements: BEAD-202 (manual E2E script captures this flow)\n\n","status":"closed","priority":1,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":30,"created_at":"2026-01-25T18:52:37.078133-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:47:03.417811-05:00","closed_at":"2026-01-25T18:57:29.135857-05:00","close_reason":"Fixed: Added 60s timeout with 15s periodic reminders to auto-monitor wait loop","labels":["high","phase1","ux"],"dependencies":[{"issue_id":"savant_elite_rust-9fm","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.448547-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-bq1","title":"BEAD-002: Config file newline injection vulnerability","description":"# What / why\n\n`PedalConfig` persists the most recently programmed pedal mappings to disk so the CLI can display configuration later (e.g. `savant info` can show a visualization even though the device EEPROM is effectively write-only).\n\nThe on-disk format is a simple line-based key/value file:\n\n```\nleft=cmd+c\nmiddle=cmd+a\nright=cmd+v\n```\n\nBefore this bead, the save path accepted arbitrary strings for each value and wrote them verbatim. If a value contained a newline, the file structure could be corrupted.\n\nThis matters because it creates a **config injection / corruption** vector:\n- A user (or script) can supply a key action containing `\\n` or `\\r` via shell quoting (e.g. `$'cmd+c\\nright=evil'`).\n- The config file now contains extra lines that the loader will interpret as additional keys.\n- Result: `PedalConfig::load()` can misparse, and the UI may display incorrect mappings (or fall back to “unknown”).\n\nEven though this is “just” a local config file, this is still worth fixing because:\n- it breaks UX and trust in `savant info`\n- it’s an easy mistake to make when piping inputs\n- it’s a low-effort hardening win\n\n# Scope\n\n- Reject any key-action value containing `\\n` or `\\r` during serialization/saving.\n- Keep parsing behavior permissive (ignore unknown keys) but ensure we never *write* malformed structure.\n\nOut of scope:\n- escaping newlines (we want to keep the format simple and unambiguous)\n\n# Design / approach\n\nImplement the validation in the lowest-friction place:\n- In `PedalConfig::serialize()` (called by `save_to()` / `save()`), iterate over `left`, `middle`, `right`.\n- If a value contains `\\n` or `\\r`, return an error with the field name (`left`/`middle`/`right`) so the user knows what to fix.\n\nThis ensures:\n- *all* save paths are protected (including tests)\n- callers don’t need to remember to validate separately\n\n# Testing\n\nUnit tests (BEAD-103):\n- `pedal_config_rejects_newline_in_value`\n- `pedal_config_rejects_carriage_return_in_value`\n\n# Acceptance criteria\n\n- `PedalConfig::save()` fails with a clear error if any value contains `\\n` or `\\r`.\n- The error message identifies which field is invalid.\n- Normal values (`cmd+c`, etc.) are unaffected.\n\n# Related beads\n\n- Validated by: BEAD-103\n- Related UX: BEAD-203 (manual config script assumes the file format is stable)\n\n","status":"closed","priority":1,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":15,"created_at":"2026-01-25T18:52:20.323998-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:46:39.493068-05:00","closed_at":"2026-01-25T18:55:13.967001-05:00","close_reason":"Fixed: Added validation to reject newlines/carriage returns in PedalConfig values","labels":["high","input-validation","phase1","security"],"dependencies":[{"issue_id":"savant_elite_rust-bq1","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.499423-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-bws","title":"BEAD-304: Add TESTING.md","description":"# What / why\n\nWe want a single top-level doc that answers “how do I validate changes?” without searching the repo.\n\n`TESTING.md` is that entrypoint:\n- how to run automated tests\n- what manual scripts exist\n- what prerequisites/caveats apply\n\nThis reduces regressions and makes future changes safer.\n\n# Scope\n\nAdd `TESTING.md` documenting:\n- `cargo test` (unit + integration)\n- manual scripts:\n  - `tests/e2e_hardware_sim.sh`\n  - `tests/e2e_config.sh`\n- where logs go (`tests/logs/`)\n- macOS requirements (Input Monitoring permission, possible `sudo` for USB)\n\n# Acceptance criteria\n\n- `TESTING.md` exists and is accurate.\n- New contributors (or future self) can validate changes quickly.\n\n","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T20:44:46.535866-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:52:26.381001-05:00","closed_at":"2026-01-25T20:55:37.152181-05:00","close_reason":"Added top-level TESTING.md documenting how to run unit/integration tests and the manual E2E scripts.","labels":["docs","phase5","test"],"dependencies":[{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.174349-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-qvt","type":"blocks","created_at":"2026-01-25T23:54:03.609414-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-wyy","type":"blocks","created_at":"2026-01-25T23:54:03.656168-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-51c","type":"blocks","created_at":"2026-01-25T23:54:03.709091-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-yyo","type":"blocks","created_at":"2026-01-25T23:54:03.751149-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-9dr","type":"blocks","created_at":"2026-01-25T23:54:03.791176-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-3cr","type":"blocks","created_at":"2026-01-25T23:54:03.835216-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-cbv","title":"Installer: accept SAVANT_VERSION with leading v","description":"install.sh built /releases/download/vvX when users pass SAVANT_VERSION=vX; normalize by stripping a leading 'v'.","status":"closed","priority":3,"issue_type":"bug","created_at":"2026-01-26T02:29:53.340938-05:00","created_by":"jemanuel","updated_at":"2026-01-26T02:30:01.011337-05:00","closed_at":"2026-01-26T02:30:01.011337-05:00","close_reason":"Stripped optional leading 'v' from SAVANT_VERSION before constructing download URLs."}
{"id":"savant_elite_rust-cj2","title":"BEAD-021: Add read-back verification after programming","description":"# What / why\n\nUSB control-transfer success only tells us “the device accepted the packet,” not “the device actually stored the intended mapping.”\n\nGiven that Savant Elite units can have firmware variations and we already support multiple SET_REPORT formats, it’s valuable to add a **best-effort read-back verification** step after programming each pedal.\n\nThis helps users trust the tool:\n- if the device supports read-back, we can confirm that the (modifier, keycode) we wrote matches what the device reports\n- if it doesn’t support read-back, programming still works (we just can’t verify automatically)\n\n# Scope\n\n- After a successful `CMD_SET_KEY_MACRO` send, attempt to read back the pedal mapping via `CMD_GET_KEY_MACRO` (0xCD).\n- Compare the read-back modifier byte + keycode to what we attempted to write.\n- If mismatch is detected, warn the user to verify manually.\n- If the device does not support GET_KEY_MACRO (or response format is unknown), silently skip verification (no hard failure).\n\nOut of scope:\n- making programming fail if verification is unsupported\n- implementing full EEPROM readback or macro sequences\n\n# Design / approach\n\nImplementation strategy (robust across firmware quirks):\n\n1. Implement a helper:\n   - `verify_pedal_programming(handle, interface, pedal_idx, expected_mod, expected_key) -\u003e Result\u003cbool\u003e`\n2. Perform HID `GET_REPORT` control transfers using multiple `wValue` patterns:\n   - feature report, report-id = 0\n   - feature report, report-id = CMD\n   - input report variants\n3. Parse likely response layouts:\n   - `[CMD, pedal, mod, key, ...]`\n   - `[0, CMD, pedal, mod, key, ...]`\n   - `[pedal, mod, key, ...]`\n4. Return:\n   - `Ok(true)` if exact match\n   - `Ok(false)` if definite mismatch\n   - `Err(_)` if unsupported / no parseable response\n\nUX behavior:\n- On `Ok(true)`: print a small “Verified” line (quiet success).\n- On `Ok(false)`: print a warning indicating mismatch and that manual verification is needed.\n- On `Err(_)`: do nothing; this keeps output clean for devices that don’t support readback.\n\n# Testing\n\nAutomated tests are not included because:\n- this depends on device firmware supporting GET_REPORT/GET_KEY_MACRO\n- mocking `rusb::DeviceHandle` is non-trivial and would add brittle test infrastructure\n\nManual validation:\n- Use `tests/e2e_hardware_sim.sh` (BEAD-202) and observe that after programming, the tool may print “Verified” lines (firmware dependent).\n\n# Acceptance criteria\n\n- After successfully programming a pedal, the tool attempts read-back verification.\n- If verification succeeds, output includes a quiet success indicator.\n- If verification returns a mismatch, output includes a warning.\n- If verification is unsupported, programming continues with no extra noise.\n\n# Related beads\n\n- Builds on: BEAD-020 (programming safety; we already handle disconnects)\n\n","status":"closed","priority":2,"issue_type":"feature","assignee":"claude-opus","estimated_minutes":120,"created_at":"2026-01-25T18:53:04.148903-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:01.658816-05:00","closed_at":"2026-01-25T19:33:21.887199-05:00","close_reason":"Implemented verify_pedal_programming() using GET_KEY_MACRO (0xCD) with multiple format attempts. Best-effort verification that gracefully handles unsupported firmware.","labels":["hardening","phase2"],"dependencies":[{"issue_id":"savant_elite_rust-cj2","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.91223-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-cj2","depends_on_id":"savant_elite_rust-7h5","type":"blocks","created_at":"2026-01-25T23:54:03.150759-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-cj2","depends_on_id":"savant_elite_rust-kdb","type":"relates-to","created_at":"2026-01-25T23:54:03.923948-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-fjx","title":"BEAD-022: Improve HidApi lifecycle management","description":"# What / why\n\nThe codebase uses `hidapi` for device enumeration and for reading Play-mode input.\n\nBefore this bead, `SavantElite::new()` did a “smoke check” by constructing a `HidApi` instance and immediately dropping it. Then most methods constructed a fresh `HidApi` again.\n\nThis pattern is suboptimal:\n- redundant work on every CLI invocation\n- confusing failure modes (init might fail in `new()` but succeed later, or vice versa)\n- gives a false impression that `SavantElite` maintains a long-lived HID context (it didn’t)\n\n# Scope\n\nPick one clear approach:\n- Either store `HidApi` on `SavantElite`, or\n- Remove the redundant init-check and let each command initialize when needed.\n\n# Design decision\n\nWe chose the minimal/least-risk option:\n- **Remove the init-check in `SavantElite::new()`**.\n\nRationale:\n- `HidApi::new()` is already called by each command that needs it.\n- Keeping HID enumeration local to the command avoids lifetime tangles with `HidDevice` handles.\n- Avoids giving the impression that `SavantElite` holds state that must be kept fresh.\n\n# Testing\n\nNo new tests needed:\n- behavior is unchanged except removing redundant work\n\n# Acceptance criteria\n\n- `SavantElite::new()` no longer initializes `HidApi` as a side-effect.\n- Commands that need HID still initialize it and surface a contextual error if init fails.\n\n","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T20:44:25.465944-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:25.152586-05:00","closed_at":"2026-01-25T20:55:17.533443-05:00","close_reason":"Removed redundant HidApi initialization check in SavantElite::new(); commands now initialize HidApi only when needed.","labels":["cleanup","hardening","phase2"],"dependencies":[{"issue_id":"savant_elite_rust-fjx","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.280776-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-flg","title":"BEAD-105: Interface number validation test coverage","description":"# What / why\n\nBEAD-005 adds clap validation for the `--interface` argument in `raw-cmd`.\n\nBecause the validation happens *inside clap parsing*, the best way to assert it stays correct is an integration test that:\n- invokes the compiled `savant` binary\n- passes invalid arguments\n- verifies clap rejects them\n\nThis bead exists to explicitly connect:\n- BEAD-005 (the validation change)\n- BEAD-201 (the test coverage)\n\n# Scope\n\nNo separate unit tests are added.\n\nInstead, enforce coverage via BEAD-201 integration tests:\n- `cli_raw_cmd_rejects_negative_interface`\n- `cli_raw_cmd_rejects_interface_too_large`\n\n# Acceptance criteria\n\n- Those integration tests exist and pass.\n- They fail if the clap range validation is removed.\n\n","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T23:43:17.51836-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:27.036078-05:00","closed_at":"2026-01-25T23:43:21.664235-05:00","close_reason":"Covered by BEAD-201 integration tests (cli_raw_cmd_rejects_negative_interface + cli_raw_cmd_rejects_interface_too_large); no separate unit test needed for clap-level validation.","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-flg","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.125456-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-flg","depends_on_id":"savant_elite_rust-5iu","type":"validates","created_at":"2026-01-25T23:54:03.10339-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-i35","title":"BEAD-006: Config not saved on partial programming success","description":"# What / why\n\n`savant program` has two “sources of truth”:\n- the **device EEPROM** (persistent hardware configuration)\n- a **local config file** (for UI display + user intent + quick retry)\n\nThe local config file is important because:\n- the device EEPROM is effectively write-only (no reliable readback in all firmware)\n- users want `savant info` to show what they last programmed\n- if something fails at the end of the sequence, the tool can still remember what the user was trying to do\n\nBefore this bead, if pedal programming succeeded but the final EEPROM save step failed, we did **not** write the config file. That loses user intent and makes retries harder.\n\nExample failure modes:\n- EEPROM save control transfer fails due to a transient USB hiccup\n- permission/driver issues during final stage\n\nIn these cases, the user often *still wants the config persisted*, even if we warn that it might not have been saved to EEPROM.\n\n# Scope\n\n- Always write the attempted config to disk **after** we’ve finished the programming sequence, even if:\n  - one or more pedals failed, and/or\n  - EEPROM save may have failed\n\n- Do **not** write a config on “hard abort” situations where we explicitly tell the user the device disconnected mid-run and changes were lost in RAM.\n\n# Design / approach\n\n- Construct a `PedalConfig { left, middle, right }` from the requested actions.\n- Call `config.save()` unconditionally at the end of the programming path.\n- If saving the config file fails, print a *non-fatal* note.\n\nThis preserves intent without pretending the device is guaranteed to be programmed.\n\nUX detail:\n- If EEPROM save fails, print a warning like “changes might not persist after unplug”.\n- Still show the pedal visualization so the user can verify what was attempted.\n\n# Testing\n\nAutomated coverage:\n- BEAD-106 covers `PedalConfig` persistence mechanics (serialize/save/load/whitespace parsing).\n\nManual validation (hardware):\n- Use BEAD-202 to run `savant program` and confirm that after a programming attempt, `savant info` reflects the saved config.\n- If you can force an EEPROM-save failure (hard, device/OS dependent), verify:\n  - the tool warns about persistence\n  - the config file still updates to the attempted mapping\n\n# Acceptance criteria\n\n- After any completed programming attempt (even with warnings), the local config file is updated to the requested mapping.\n- `savant info` uses this file to render the pedal visualization.\n- If config save fails, the CLI prints a non-fatal note; programming result reporting remains intact.\n\n# Related beads\n\n- Validated by: BEAD-106 (persistence tests), BEAD-202 (manual hardware flow)\n\n","status":"closed","priority":2,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":30,"created_at":"2026-01-25T18:52:37.265637-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:48:02.107793-05:00","closed_at":"2026-01-25T18:57:29.287111-05:00","close_reason":"Fixed: Config now saved regardless of programming success for user intent preservation","labels":["data-loss","medium","phase1"],"dependencies":[{"issue_id":"savant_elite_rust-i35","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.019392-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-ip9","title":"Fix deprecated assert_cmd::Command::cargo_bin usage","description":"# What / why\n\n`assert_cmd::Command::cargo_bin(\"savant\")` can emit a deprecation warning depending on assert_cmd version.\n\nCI should be warning-clean so that:\n- real regressions stand out\n- contributors don’t habituate to ignoring CI output\n\n# Scope\n\n- Remove usage of deprecated `Command::cargo_bin` API in integration tests.\n- Prefer the stable approach provided by cargo during tests:\n  - `env!(\"CARGO_BIN_EXE_savant\")`\n\n# Acceptance criteria\n\n- `cargo test` runs without the deprecation warning.\n- Integration tests continue to work on CI.\n\n","status":"closed","priority":3,"issue_type":"task","estimated_minutes":15,"created_at":"2026-01-25T19:44:34.058988-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:52:33.634406-05:00","closed_at":"2026-01-25T20:07:50.028258-05:00","close_reason":"No longer applicable (already fixed)","labels":["infra","test"],"dependencies":[{"issue_id":"savant_elite_rust-ip9","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.329296-05:00","created_by":"jemanuel"}],"comments":[{"id":2,"issue_id":"savant_elite_rust-ip9","author":"jemanuel","text":"Reviewed current tree: no  usage remains (tests use ). Closing as already resolved.","created_at":"2026-01-26T01:07:35Z"},{"id":3,"issue_id":"savant_elite_rust-ip9","author":"jemanuel","text":"Reviewed current tree: no Command::cargo_bin usage remains (tests use env!(\"CARGO_BIN_EXE_savant\")). Closing as already resolved.","created_at":"2026-01-26T01:07:45Z"}]}
{"id":"savant_elite_rust-kdb","title":"BEAD-021 (duplicate): Add read-back verification after programming","description":"# NOTE: duplicate / historical artifact\n\nThis bead is a **duplicate** of the canonical BEAD-021 implementation:\n- Canonical: `savant_elite_rust-cj2` (BEAD-021)\n\nWhy keep this around?\n- It records that BEAD-021 was accidentally created twice during plan → beads conversion.\n- It provides an explicit cross-reference so future triage doesn’t wonder “why are there two BEAD-021s?”\n\n# What to do\n\n- Do not implement work under this bead.\n- If you need the actual spec + rationale + acceptance criteria, use `savant_elite_rust-cj2`.\n\n","status":"closed","priority":2,"issue_type":"feature","estimated_minutes":120,"created_at":"2026-01-25T18:53:12.158387-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:12.369701-05:00","closed_at":"2026-01-25T19:37:57.932002-05:00","close_reason":"Duplicate of cj2 - read-back verification already implemented in verify_pedal_programming()","labels":["hardening","phase2"],"dependencies":[{"issue_id":"savant_elite_rust-kdb","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.860675-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-kdb","depends_on_id":"savant_elite_rust-cj2","type":"relates-to","created_at":"2026-01-25T23:54:03.923332-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-liu","title":"Multi-pass bug hunt: harden program + scripts","description":"Audit + fix small issues found by UBS/shellcheck: remove a non-test unwrap in program path; make e2e_config.sh shellcheck-clean.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T00:22:52.079127-05:00","created_by":"jemanuel","updated_at":"2026-01-26T00:23:17.19368-05:00","closed_at":"2026-01-26T00:23:17.19368-05:00","close_reason":"Implemented fixes and re-ran fmt/test/clippy/shellcheck/ubs."}
{"id":"savant_elite_rust-o0s","title":"BEAD-108: Unit tests for modifier parsing coverage","description":"# What / why\n\nModifiers are the hardest part of key-action parsing because:\n- users type many aliases (`cmd`, `command`, `gui`, `meta`, `super`)\n- modifier order shouldn’t matter\n- duplicates shouldn’t change behavior\n- casing varies\n\nIf modifier parsing is wrong, the device is programmed successfully but emits incorrect shortcuts.\n\nThis bead adds comprehensive tests to lock in expected modifier behavior.\n\n# Scope\n\nUnit tests should cover:\n\nAliases:\n- GUI/Cmd: `cmd`, `command`, `gui`, `meta`, `super`\n- Ctrl: `ctrl`, `control`\n- Alt/Option: `alt`, `option`, `opt`\n- Shift: `shift`\n\nCombinatorics / robustness:\n- all four modifiers combined\n- order independence (`cmd+ctrl+a` == `ctrl+cmd+a`)\n- duplicate modifiers are idempotent (`cmd+cmd+a`)\n- case-insensitivity (`CMD+a` == `cmd+a`)\n\nAlso valuable:\n- combinations with function keys / special keys / arrows / punctuation to ensure the “last token is key” rule is stable across key families.\n\n# Test design\n\nPrefer table-driven loops for combinations to keep tests concise but exhaustive.\n\n# Acceptance criteria\n\n- All supported aliases map to the intended HID modifier bits.\n- Parsing is order-independent and case-insensitive.\n- Duplicate modifiers do not change the result.\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:34:38.88079-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:59.937858-05:00","closed_at":"2026-01-25T20:38:59.422782-05:00","close_reason":"Added comprehensive unit tests for modifier parsing: all GUI aliases (cmd/command/gui/meta/super), all CTRL aliases (ctrl/control), all ALT aliases (alt/option/opt), shift, mixed alias combinations, 2-modifier and 3-modifier combinations, modifiers with function keys, special keys, arrow keys, punctuation, and case variations. Total: 8 new test functions covering 77+ test cases.","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-o0s","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.758245-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-qvt","title":"BEAD-301: Add test dependencies to Cargo.toml","description":"# What / why\n\nWe want two automated test layers:\n- integration tests via `assert_cmd`\n- unit tests that use temporary directories/files safely\n\nSo we need a small set of dev-dependencies.\n\n# Scope\n\nAdd to `Cargo.toml` under `[dev-dependencies]`:\n- `assert_cmd` (CLI integration testing)\n- `predicates` (assertions on stdout/stderr)\n- `tempfile` (safe filesystem isolation)\n\n# Acceptance criteria\n\n- `cargo test` builds and runs with these dev-deps.\n- No runtime dependency impact for release builds.\n\n","status":"closed","priority":1,"issue_type":"task","assignee":"claude-opus","estimated_minutes":5,"created_at":"2026-01-25T18:53:12.281581-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:52:00.944795-05:00","closed_at":"2026-01-25T19:33:56.672035-05:00","close_reason":"Added dev-dependencies: assert_cmd 2, predicates 3, tempfile 3","labels":["infra","phase5"],"dependencies":[{"issue_id":"savant_elite_rust-qvt","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.094688-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-wyy","title":"BEAD-302: Add tests/ README and script scaffolding","description":"# What / why\n\nWe want the `tests/` directory to be self-explanatory:\n- what automated tests exist\n- what manual scripts exist\n- what prerequisites are required (hardware, permissions)\n\nWithout documentation, future maintenance is slow and error-prone.\n\n# Scope\n\n- Add `tests/README.md` explaining:\n  - unit vs integration tests\n  - manual scripts and when to run them\n  - macOS-specific requirements (Input Monitoring, sudo)\n\n- Ensure manual scripts exist under `tests/`:\n  - `tests/e2e_hardware_sim.sh` (BEAD-202)\n  - `tests/e2e_config.sh` (BEAD-203)\n\n- Ensure generated logs go to `tests/logs/` and are ignored by git.\n\n# Acceptance criteria\n\n- `tests/README.md` exists and points at the correct scripts.\n- `tests/logs/` is gitignored.\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:44:42.541732-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:52:09.820864-05:00","closed_at":"2026-01-25T20:55:33.491697-05:00","close_reason":"Added tests/README.md and checked in manual E2E scripts under tests/; ignored generated logs via /tests/logs/ in .gitignore.","labels":["infra","phase5","test"],"dependencies":[{"issue_id":"savant_elite_rust-wyy","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.54991-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-wyy","depends_on_id":"savant_elite_rust-qvt","type":"blocks","created_at":"2026-01-25T23:54:03.46892-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-xc1","title":"BEAD-103: Unit tests for PedalConfig newline handling","description":"# What / why\n\nThis bead adds unit tests for the security/robustness fix in BEAD-002.\n\nWe want to guarantee that config values written to disk cannot contain embedded newlines or carriage returns, because the config file is line-based.\n\n# Scope\n\nAdd tests that assert:\n- `PedalConfig::save()` rejects values containing `\\n`\n- `PedalConfig::save()` rejects values containing `\\r`\n\n# Test design / safety\n\nImportant: these tests should not modify real user config.\n\nThe chosen pattern is safe because:\n- validation happens during serialization **before** any filesystem write\n- the test inputs are intentionally invalid (contain `\\n`/`\\r`), so `save()` errors out early\n\n# Acceptance criteria\n\n- Tests fail if newline validation is removed or weakened.\n- Error message mentions “newline” so the failure is understandable.\n\n# Related beads\n\n- Validates: BEAD-002\n\n","status":"closed","priority":1,"issue_type":"task","estimated_minutes":20,"created_at":"2026-01-25T18:52:49.282022-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:09.378619-05:00","closed_at":"2026-01-25T18:55:14.010658-05:00","close_reason":"Tests added in same commit as BEAD-002 fix","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-xc1","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.298165-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-xc1","depends_on_id":"savant_elite_rust-bq1","type":"validates","created_at":"2026-01-25T23:54:02.953419-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-yma","title":"BEAD-106: Unit tests for PedalConfig save/load roundtrip","description":"# What / why\n\n`PedalConfig` is the on-disk record of the last programmed pedal mappings.\n\nEven though it’s simple, it needs to be robust because:\n- users may hand-edit the file\n- earlier versions might write slightly different whitespace\n- we may add new keys later (forward compatibility)\n\nThis bead adds unit tests that lock in the intended config semantics:\n- roundtrip correctness\n- tolerant parsing (whitespace, unknown keys)\n- safe behavior when the file is missing or incomplete\n\n# Scope\n\nAdd tests for:\n- **Roundtrip**: save a config, read it back, values match.\n- **Missing file**: `load_from()` returns `None` (not error).\n- **Partial file**: missing any of `left/middle/right` returns `None`.\n- **Whitespace**: keys/values are trimmed; blank lines ignored; unknown keys ignored.\n\n# Test design\n\nUse `tempfile::tempdir()` and explicit `save_to(path)` / `load_from(path)` to avoid touching real user config.\n\nParsing rules under test:\n- `left`, `middle`, `right` must all be present and non-empty.\n- extra lines are ignored (forward compatibility).\n\n# Acceptance criteria\n\n- Tests are deterministic and do not require hardware.\n- Tests pass on clean machines with no existing config.\n\n# Related beads\n\n- Supports: BEAD-006 (preserving user intent relies on config persistence)\n\n","status":"closed","priority":1,"issue_type":"task","assignee":"claude-opus-4.5","estimated_minutes":45,"created_at":"2026-01-25T18:52:49.40373-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:37.883752-05:00","closed_at":"2026-01-25T19:44:06.762435-05:00","close_reason":"Closed","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-yma","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.247019-05:00","created_by":"jemanuel"}],"comments":[{"id":1,"issue_id":"savant_elite_rust-yma","author":"jemanuel","text":"Claimed by Codex. Adding PedalConfig save/load roundtrip + whitespace/partial/missing-file unit tests (no real user config writes); will run cargo test and sync.","created_at":"2026-01-26T00:37:02Z"},{"id":4,"issue_id":"savant_elite_rust-yma","author":"jemanuel","text":"Follow-up: updated PedalConfig persistence unit tests to use tempfile::tempdir (auto-cleaning) instead of creating ad-hoc temp directories.","created_at":"2026-01-26T01:07:54Z"}]}
{"id":"savant_elite_rust-yyo","title":"BEAD-201: CLI argument validation E2E tests","description":"# What / why\n\nWe need strong coverage that the CLI rejects invalid inputs **before** it touches hardware.\n\nConstraints:\n- CI cannot rely on physical Savant Elite hardware.\n- Many validation rules are pure string parsing / clap validation.\n\nSo we use integration tests (`assert_cmd`) that execute the compiled `savant` binary and assert:\n- exit status\n- stderr/stdout contains helpful messages\n\nThis is the best way to lock in user-facing behavior.\n\n# Scope\n\nIntegration tests should cover (at minimum):\n\n`program` command (no hardware):\n- empty pedal values rejected\n- invalid key names rejected\n- invalid modifier names rejected\n- malformed plus forms rejected (leading/trailing/consecutive/only-plus)\n- valid combinations succeed under `--dry-run`\n\n`raw-cmd` command:\n- invalid hex command rejected\n- invalid hex data rejected\n- odd-length hex rejected\n- negative / too-large interface rejected (clap)\n- data payload too long rejected\n\nGeneral CLI:\n- `--help` and `--version` succeed\n- unknown subcommand rejected\n\n# Test design\n\nKey property: **tests must be hardware-independent**.\n\nTechniques:\n- always pass `--dry-run` for `program` so key parsing is exercised without USB access\n- use `env!(\"CARGO_BIN_EXE_savant\")` (or equivalent) to avoid deprecated `Command::cargo_bin` APIs\n- match error messages by stable substrings (avoid brittle full-string equality)\n\n# Acceptance criteria\n\n- `cargo test` passes on machines with no Savant Elite device connected.\n- Integration tests cover the major invalid-input classes described above.\n- Errors remain actionable (contain “cannot be empty”, “Unknown key”, etc.).\n\n# Related beads\n\n- Covers/validates: BEAD-001, BEAD-004, BEAD-005, BEAD-105\n\n","status":"closed","priority":1,"issue_type":"task","assignee":"claude-opus-4.5","estimated_minutes":120,"created_at":"2026-01-25T18:53:12.222244-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:51:21.950369-05:00","closed_at":"2026-01-25T19:41:26.396359-05:00","close_reason":"Fixed all E2E tests: 30 tests now passing. Updated tests to match actual error messages and CLI behavior.","labels":["e2e","phase4","test"],"dependencies":[{"issue_id":"savant_elite_rust-yyo","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.147719-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-yyo","depends_on_id":"savant_elite_rust-qvt","type":"blocks","created_at":"2026-01-25T23:54:03.19315-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-yyo","depends_on_id":"savant_elite_rust-4eo","type":"validates","created_at":"2026-01-25T23:54:03.239232-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-yyo","depends_on_id":"savant_elite_rust-6hu","type":"validates","created_at":"2026-01-25T23:54:03.281345-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-yyo","depends_on_id":"savant_elite_rust-5iu","type":"validates","created_at":"2026-01-25T23:54:03.331196-05:00","created_by":"jemanuel"}]}
