{"id":"savant_elite_rust-0ac","title":"BEAD-109: Keyboard report normalization edge-case unit tests","description":"# What / why\n\n`savant monitor` reads keyboard-style HID reports and tries to interpret what the pedal is sending.\n\nIn practice, HID backends sometimes vary the raw report framing:\n- some include a leading report-id byte (often 0)\n- some pad reports to a larger endpoint size\n\n`usb_hid::normalize_boot_keyboard_report(data)` normalizes these variants to the canonical 8-byte boot keyboard report.\n\nThis bead adds edge-case tests so we don’t regress normalization logic.\n\n# Scope\n\nUnit tests should cover:\n- input shorter than 8 bytes returns `None`\n- exactly 8 bytes returns that exact report\n- all zeros returns all zeros\n- a “max keys pressed” style report returns unchanged\n\n# Acceptance criteria\n\n- Tests are deterministic and do not require hardware.\n- Tests fail if normalize logic starts accepting too-short data or corrupting the canonical report.\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:44:21.330818-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:51:08.756113-05:00","closed_at":"2026-01-25T20:55:12.296053-05:00","close_reason":"Added missing normalize_boot_keyboard_report edge-case unit tests (too-short input, all-zeros report, all-keys-pressed) and made the existing exact-8-byte case explicit.","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-0ac","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.705682-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-1hk","title":"Add automatic config backup before changes","description":"# What / Why\n\nAccidental config loss is frustrating:\n- User runs `savant program` with wrong arguments\n- Previous config is overwritten\n- No way to recover without remembering exact previous settings\n\nAutomatic backup before changes provides safety net:\n- Each programming operation backs up current config\n- Users can restore previous configurations\n- History provides audit trail\n\nThis is the \"git for your config\" pattern - never lose work.\n\n# Background\n\nConfig file location: `~/.config/savant-elite/pedals.conf`\n\nCurrent behavior:\n- `savant program` overwrites config on success\n- No backup, no history\n- Previous config is lost\n\nProposed:\n- Before overwriting, copy to backup directory\n- Keep N most recent backups\n- Provide restore command\n\n# Scope\n\n## Deliverables\n\n1. **Automatic backup** - Before any config change, backup current config\n2. **`savant config history`** - List recent configurations\n3. **`savant config restore \u003cN\u003e`** - Restore Nth previous config\n4. **Backup rotation** - Keep last 10 configs, prune older\n5. **Timestamp-based names** - Backups named by date/time\n\n## Backup storage\n\n```\n~/.config/savant-elite/\n├── pedals.conf           # Current config\n└── history/\n    ├── 2024-01-15_143022.conf\n    ├── 2024-01-15_091547.conf\n    └── 2024-01-14_220315.conf\n```\n\n## CLI interface\n\n```bash\n# List config history\nsavant config history\n\n# Output:\nCONFIG HISTORY (most recent first)\n\n  1. 2024-01-15 14:30:22  cmd+c, cmd+a, cmd+v\n  2. 2024-01-15 09:15:47  f1, f2, f3\n  3. 2024-01-14 22:03:15  ctrl+z, ctrl+a, ctrl+y\n\nUse 'savant config restore \u003cN\u003e' to restore a previous config.\n\n# Restore second most recent\nsavant config restore 2\n\n# Output:\nRestoring config from 2024-01-15 09:15:47...\n\n  Left:   f1\n  Middle: f2\n  Right:  f3\n\nConfig restored. Run 'savant program' to apply to device.\n```\n\n## Behavior details\n\n### When backups are created\n\n- Before `savant program` writes new config\n- Before `savant config load` overwrites config\n- NOT on read operations (info, status)\n\n### Backup rotation\n\n- Keep 10 most recent backups\n- Delete older backups automatically\n- Configurable via environment variable? (`SAVANT_HISTORY_SIZE=20`)\n\n### Restore behavior\n\n`savant config restore N`:\n1. Copies backup to pedals.conf\n2. Does NOT program device automatically\n3. User runs `savant program` to apply\n\nRationale: Restore is a file operation. Programming is a device operation. Keep them separate for safety.\n\nAlternative: `savant config restore N --apply` to do both.\n\n# Design\n\n## Implementation approach\n\n1. Create `history/` directory on first backup\n2. Before overwriting config, copy to history with timestamp name\n3. After successful backup, check count and prune if needed\n4. `history` command lists files, parses dates, loads summaries\n5. `restore` command copies file back\n\n## Timestamp format\n\n`YYYY-MM-DD_HHMMSS.conf`\n\n- Sortable alphabetically\n- Human readable\n- Filesystem safe\n\n## Backup file format\n\nSame as regular config (just a copy):\n```\nleft=cmd+c\nmiddle=cmd+a\nright=cmd+v\n```\n\nCould add metadata comment:\n```\n# Backed up: 2024-01-15 14:30:22\n# Before: savant program --left f1 --middle f2 --right f3\nleft=cmd+c\nmiddle=cmd+a\nright=cmd+v\n```\n\n# Testing\n\n## Automated\n\n- Integration test: programming creates backup\n- Integration test: history lists backups\n- Integration test: restore works correctly\n- Integration test: rotation prunes old backups\n- Unit test: timestamp parsing\n\n## Manual\n\n- Program several configs, verify history grows\n- Restore old config, verify correct\n- Verify rotation after 10+ changes\n\n# Acceptance Criteria\n\n- [ ] Config changes create automatic backup\n- [ ] `savant config history` lists recent configs with timestamps\n- [ ] `savant config restore N` restores Nth previous config\n- [ ] Backups stored in history/ subdirectory\n- [ ] Old backups pruned (keep 10 by default)\n- [ ] Restore does not auto-program (safety)\n\n# Dependencies\n\n- Pairs well with: config profiles (profiles + history = full safety)\n- Works with: JSON output for history listing\n\n# Considerations\n\n## Why not git?\n\nGit is overkill for a single file:\n- Requires user to have git\n- Adds complexity\n- Single-file history is simpler\n\nCould add `savant config export-git` later if users want full VCS.\n\n## Storage space?\n\nEach backup is ~50 bytes. 10 backups = 500 bytes. Negligible.\n\n## Cross-platform timestamps?\n\nUse UTC internally, display in local time. Avoid filesystem timestamp issues.\n\n# Estimated Effort\n\nMedium: File operations, date handling, history UI, rotation logic.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-26T13:21:34.075142-05:00","created_by":"jemanuel","updated_at":"2026-01-26T13:21:34.075142-05:00"}
{"id":"savant_elite_rust-1pa","title":"PLAN: Savant Elite bug fixes, tests, hardening","description":"# Purpose / why this exists\n\nThis bead is the **single source of truth** for the original `BEADS.md` plan.\n\nGoal: keep the project runnable, safe, and maintainable by capturing *all* intended work as beads with explicit dependencies and test coverage, so future work does **not** require consulting `BEADS.md` (or reconstructing context from commits).\n\nThis plan is written for a “future self” coming back cold:\n- what the tool does\n- what can go wrong (user-impacting failure modes)\n- what we chose to harden and why\n- how we test it (unit/integration/manual)\n\n# Project context (quick refresher)\n\n`savant-elite` is a native macOS CLI (`savant`) for programming a discontinued Kinesis Savant Elite USB foot pedal.\n\nHardware behavior that drives the architecture:\n- The device has a physical **Play / Program** switch.\n- Each mode presents a different USB PID.\n- Programming writes permanent mappings to device EEPROM via HID-class control transfers.\n\nSoftware architecture (high level):\n- **CLI layer**: clap parsing + friendly UX output.\n- **Key parsing**: parse strings like `cmd+shift+c` → (modifier byte, HID keycode).\n- **Device access**:\n  - Play mode: enumerate and read input via `hidapi`.\n  - Program mode: send programming commands via `rusb`/libusb.\n- **Local config file**: stores last programmed mapping so `savant info` can visualize configuration even though the device EEPROM is write-only.\n\n# Over-arching goals for this plan\n\n1. **Fail fast on user input** (clear errors, no cryptic messages).\n2. **Make device programming safe** (avoid silent truncation, handle disconnects, best-effort verification).\n3. **Make behavior testable**:\n   - pure parsing + serialization covered by unit tests\n   - clap validation + CLI parsing covered by integration tests\n   - hardware flows captured in manual scripts with *detailed logging*\n4. **Keep CI signal high**: no spurious warnings, tests are deterministic (no hardware required).\n\n# Testing strategy (what to run and when)\n\nAutomated:\n- `cargo test` runs:\n  - unit tests in `src/main.rs` (pure logic)\n  - integration tests in `tests/cli_validation.rs` (CLI argument validation)\n\nManual (hardware required; not run in CI):\n- `tests/e2e_hardware_sim.sh` (guided + logged)\n- `tests/e2e_config.sh` (safe backup/restore + format checks + optional manual verification)\n\nLogs:\n- Manual scripts should create timestamped logs under `tests/logs/`.\n- Log output should include command lines, timestamps, and any manual-check prompts.\n\n# Bead map (the actual work)\n\nPhase 1 — Critical bug fixes (input validation + safety)\n- BEAD-001: KeyAction input validation (empty/plus edge cases) + tests (BEAD-101/102)\n- BEAD-002: Config file newline injection protection + tests (BEAD-103)\n- BEAD-003: Auto-monitor wait loop timeout/reminders (hardware-only validation)\n- BEAD-004: raw-cmd data length truncation fix + coverage (BEAD-104)\n- BEAD-005: clap validation for `--interface` + coverage (BEAD-105)\n- BEAD-006: persist config even on partial programming success + coverage (BEAD-106)\n- BEAD-007: add error context for kernel driver detach\n\nPhase 2 — Hardening (device safety + protocol robustness)\n- BEAD-020: detect USB disconnects mid-program + improve messaging\n- BEAD-021: best-effort read-back verification with GET_KEY_MACRO\n- BEAD-022: HidApi lifecycle cleanup\n- BEAD-023: eliminate HID magic numbers via usb_constants\n\nPhase 3 — Unit tests (parsing coverage)\n- BEAD-107: HID keycode table coverage\n- BEAD-108: modifier alias/combo parsing coverage\n- BEAD-109: boot keyboard report normalization edge cases\n\nPhase 4 — Integration/E2E\n- BEAD-201: CLI validation integration tests (no hardware)\n- BEAD-202: manual hardware test script with detailed logging\n- BEAD-203: manual config persistence script with detailed logging\n\nPhase 5 — Infra/docs\n- BEAD-301: dev-deps for tests\n- BEAD-302: tests/ docs + script scaffolding\n- BEAD-303: CI updates to run tests cleanly\n- BEAD-304: top-level TESTING.md\n\n# Dependency rules (how the graph should read)\n\n- Tests should depend on the functionality they validate (use dependency type `validates` when appropriate).\n- Infra/docs beads should depend on prerequisites (e.g., CI depends on tests existing).\n- Avoid cycles; `bd dep cycles` must remain empty.\n\n# Canonical docs\n\n- `README.md` — user-facing docs + protocol overview\n- `TESTING.md` — contributor/operator test entrypoint\n- `tests/README.md` — details on manual scripts\n\n","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-25T23:45:02.449968-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:45:11.364622-05:00","closed_at":"2026-01-25T23:45:11.364622-05:00","close_reason":"Plan captured in a single canonical epic for future reference; implementation beads are tracked in BEAD-* issues.","labels":["docs","meta","plan"]}
{"id":"savant_elite_rust-1rd","title":"BEAD-023: Add USB constants module","description":"# What / why\n\nThe programming logic relies on low-level USB/HID control transfers.\n\nBefore this bead, several “magic numbers” were scattered across the codebase:\n- request types (`0x21`, `0xA1`, `0x40`)\n- requests (`SET_REPORT = 0x09`, `GET_REPORT = 0x01`)\n- report-type bases (`0x0100`, `0x0200`, `0x0300`)\n\nThese values are semantically meaningful; leaving them inline makes the code harder to audit and easier to get subtly wrong.\n\n# Scope\n\n- Introduce a `usb_constants` module that names the key HID/USB constants we use.\n- Replace inline numeric literals in the programming + readback paths.\n\nOut of scope:\n- large refactors into multiple files/modules (we keep changes minimal)\n\n# Design / approach\n\nAdd a small module with descriptive constants:\n\n- HID class/interface request types:\n  - host→device class/interface (`0x21`)\n  - device→host class/interface (`0xA1`)\n- HID bRequest values:\n  - `SET_REPORT` (`0x09`)\n  - `GET_REPORT` (`0x01`)\n- HID report-type bases for wValue:\n  - input (`0x0100`)\n  - output (`0x0200`)\n  - feature (`0x0300`)\n- Vendor request type used by the alternate programming method (`0x40`)\n\nThen update call sites:\n- `handle.write_control(...)` in programming for SET_KEY_MACRO and SAVE_TO_EEPROM\n- `handle.read_control(...)` in `verify_pedal_programming()`\n\n# Testing\n\nNo tests added:\n- this is a refactor for readability and auditability\n- behavior is covered by existing unit/integration tests + manual hardware scripts\n\n# Acceptance criteria\n\n- No remaining inline HID request/report magic numbers in the core programming + verification paths.\n- Code reads like “HID_SET_REPORT” rather than “0x09”.\n\n","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T20:44:29.625592-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:38.950297-05:00","closed_at":"2026-01-25T20:55:21.835262-05:00","close_reason":"Added usb_constants module and replaced HID control-transfer magic numbers (request types, SET/GET_REPORT, report-type bases) in programming/readback paths.","labels":["cleanup","hardening","phase2"],"dependencies":[{"issue_id":"savant_elite_rust-1rd","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.225735-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-1w8","title":"E2E test script infrastructure with logging","description":"# E2E test script infrastructure with logging\n\n## What\n\nCreate a shell script infrastructure for E2E testing with detailed, structured logging that can be used both manually and in CI.\n\n## Deliverables\n\n### 1. tests/e2e/lib/logging.sh\n```bash\n#!/bin/bash\n# Structured logging library for E2E tests\n\nLOG_LEVEL=${LOG_LEVEL:-INFO}\nLOG_FILE=${LOG_FILE:-/tmp/savant-e2e-$(date +%Y%m%d-%H%M%S).log}\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m'\n\nlog_info() {\n    local msg=\"[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] $*\"\n    echo -e \"${BLUE}${msg}${NC}\"\n    echo \"$msg\" \u003e\u003e \"$LOG_FILE\"\n}\n\nlog_pass() {\n    local msg=\"[$(date '+%Y-%m-%d %H:%M:%S')] [PASS] $*\"\n    echo -e \"${GREEN}${msg}${NC}\"\n    echo \"$msg\" \u003e\u003e \"$LOG_FILE\"\n}\n\nlog_fail() {\n    local msg=\"[$(date '+%Y-%m-%d %H:%M:%S')] [FAIL] $*\"\n    echo -e \"${RED}${msg}${NC}\"\n    echo \"$msg\" \u003e\u003e \"$LOG_FILE\"\n}\n\nlog_warn() {\n    local msg=\"[$(date '+%Y-%m-%d %H:%M:%S')] [WARN] $*\"\n    echo -e \"${YELLOW}${msg}${NC}\"\n    echo \"$msg\" \u003e\u003e \"$LOG_FILE\"\n}\n\nlog_cmd() {\n    log_info \"Running: $*\"\n    local output\n    output=$(\"$@\" 2\u003e\u00261)\n    local exit_code=$?\n    echo \"$output\" \u003e\u003e \"$LOG_FILE\"\n    if [ $exit_code -eq 0 ]; then\n        log_info \"Exit code: 0\"\n    else\n        log_warn \"Exit code: $exit_code\"\n    fi\n    echo \"$output\"\n    return $exit_code\n}\n\ntest_start() {\n    log_info \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"\n    log_info \"TEST: $*\"\n    log_info \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"\n}\n\ntest_end() {\n    local result=$1\n    if [ \"$result\" = \"pass\" ]; then\n        log_pass \"TEST PASSED: $2\"\n    else\n        log_fail \"TEST FAILED: $2\"\n    fi\n    log_info \"\"\n}\n```\n\n### 2. tests/e2e/run_all.sh\n```bash\n#!/bin/bash\n# Master E2E test runner\n\nset -e\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" \u0026\u0026 pwd)\"\nsource \"$SCRIPT_DIR/lib/logging.sh\"\n\nlog_info \"Starting E2E test suite\"\nlog_info \"Savant binary: $(which savant || echo 'not in PATH')\"\nlog_info \"Log file: $LOG_FILE\"\n\nTESTS_RUN=0\nTESTS_PASSED=0\nTESTS_FAILED=0\n\nrun_test() {\n    local test_script=\"$1\"\n    log_info \"Running: $test_script\"\n    if bash \"$SCRIPT_DIR/$test_script\"; then\n        ((TESTS_PASSED++))\n    else\n        ((TESTS_FAILED++))\n    fi\n    ((TESTS_RUN++))\n}\n\n# Run all test scripts\nrun_test \"test_help_version.sh\"\nrun_test \"test_config.sh\"\nrun_test \"test_profiles.sh\"\nrun_test \"test_presets.sh\"\nrun_test \"test_doctor.sh\"\n\n# Summary\nlog_info \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"\nlog_info \"E2E TEST SUMMARY\"\nlog_info \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"\nlog_info \"Tests run: $TESTS_RUN\"\nlog_pass \"Passed: $TESTS_PASSED\"\nif [ $TESTS_FAILED -gt 0 ]; then\n    log_fail \"Failed: $TESTS_FAILED\"\n    exit 1\nelse\n    log_pass \"All tests passed!\"\nfi\n```\n\n## Directory Structure\n\n```\ntests/\n├── e2e/\n│   ├── lib/\n│   │   └── logging.sh\n│   ├── run_all.sh\n│   ├── test_help_version.sh\n│   ├── test_config.sh\n│   ├── test_profiles.sh\n│   ├── test_presets.sh\n│   ├── test_doctor.sh\n│   └── test_hardware.sh  # Optional, skipped if no device\n└── fixtures/\n    ├── valid_config.conf\n    └── invalid/\n        ├── missing_left.conf\n        ├── invalid_key.conf\n        └── malformed.conf\n```\n\n## Acceptance Criteria\n\n- [ ] Logging library with colors and file output\n- [ ] Master runner script\n- [ ] Individual test scripts can run standalone\n- [ ] Log files are timestamped and preserved\n- [ ] CI-friendly (proper exit codes)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T15:19:39.164077-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:19:39.164077-05:00"}
{"id":"savant_elite_rust-1xy","title":"Integration tests for 'savant config check' command","description":"# Test bead\n\nAutomated tests for the feature.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel","updated_at":"2026-01-27T14:29:09.404077-05:00","closed_at":"2026-01-27T14:29:09.404077-05:00","close_reason":"Implemented 'savant config check' command with 7 integration tests","dependencies":[{"issue_id":"savant_elite_rust-1xy","depends_on_id":"savant_elite_rust-xoh","type":"blocks","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-27p","title":"BEAD-102: Unit tests for KeyAction malformed plus handling","description":"# What / why\n\nThis bead adds unit tests that lock in BEAD-001’s handling of malformed `+` separators.\n\nThese are important because they’re easy for users to type accidentally, and the resulting errors should be self-explanatory.\n\n# Scope\n\nUnit tests should cover:\n- leading plus: `+c`\n- trailing plus: `cmd+`\n- only plus: `+`\n- consecutive plus: `cmd++c`\n\nOptionally (covered by integration tests, but unit tests are fine too):\n- whitespace variants like `cmd+ +c` (empty component after trimming)\n\n# Test design\n\nAssertions should:\n- ensure an error occurs\n- confirm the error message indicates the underlying issue (start/end plus, empty component, consecutive plus)\n\n# Acceptance criteria\n\n- All malformed forms above return errors.\n- Valid forms remain valid.\n\n# Related beads\n\n- Validates: BEAD-001\n\n","status":"closed","priority":1,"issue_type":"task","estimated_minutes":30,"created_at":"2026-01-25T18:52:49.218888-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:57.183-05:00","closed_at":"2026-01-25T18:54:24.607101-05:00","close_reason":"Tests added in same commit as BEAD-001 fix","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-27p","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.346154-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-27p","depends_on_id":"savant_elite_rust-4eo","type":"validates","created_at":"2026-01-25T23:54:02.870356-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-2lr","title":"Integration tests for 'savant config check' command","description":"# What / Why\n\nConfig check needs automated testing to ensure:\n- Valid configs pass\n- Invalid configs fail with clear errors\n- All validation rules work\n- JSON output works\n\n# Scope\n\n## Test cases\n\n1. **Valid config passes**\n   - Valid config file produces success exit code\n   - Valid config shows parsed values\n\n2. **Invalid config fails**\n   - Missing required keys detected\n   - Invalid key names detected\n   - Invalid modifier names detected\n\n3. **JSON output**\n   - `savant config check --json` produces valid JSON\n   - JSON includes error details on failure\n\n# Acceptance Criteria\n\n- [ ] Tests verify valid configs pass\n- [ ] Tests verify invalid configs fail with clear errors\n- [ ] Tests verify JSON output is valid\n- [ ] CI runs these tests","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T14:00:00-05:00","created_by":"jemanuel","updated_at":"2026-01-27T14:29:09.407647-05:00","closed_at":"2026-01-27T14:29:09.407647-05:00","close_reason":"Implemented 'savant config check' command with 7 integration tests","dependencies":[{"issue_id":"savant_elite_rust-2lr","depends_on_id":"savant_elite_rust-xoh","type":"blocks","created_at":"2026-01-26T14:00:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-34w","title":"BEAD-007: Missing error context for kernel driver detach","description":"# What / why\n\nWhen programming in USB “PROGRAM” mode via `rusb`/libusb, we may need to detach the kernel driver from an interface before claiming it.\n\nIf `detach_kernel_driver()` fails, the raw error from libusb is often not actionable for end users.\n\nThis bead improves UX by adding context that points users to the most common fix on macOS:\n- run with `sudo`\n\n# Scope\n\n- Wrap the `detach_kernel_driver(interface_num)` call with `anyhow::Context`.\n\nOut of scope:\n- changing when/how we detach\n\n# Design / approach\n\nUse `.context(\"Failed to detach kernel driver - try running with sudo\")` on the detach call so that:\n- the original error is preserved\n- users see immediate next steps\n\n# Testing\n\nNo automated tests:\n- this is an OS/hardware-specific failure path\n\nManual validation:\n- run `savant program` without sufficient privileges and confirm the error message includes the added context.\n\n# Acceptance criteria\n\n- When kernel detach fails, the error surfaced to the user includes “try running with sudo”.\n\n","status":"closed","priority":3,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":5,"created_at":"2026-01-25T18:52:37.323221-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:48:12.550533-05:00","closed_at":"2026-01-25T18:57:29.236818-05:00","close_reason":"Fixed: Added .context() for kernel driver detach error","labels":["error-handling","low","phase1"],"dependencies":[{"issue_id":"savant_elite_rust-34w","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.376901-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-3cr","title":"BEAD-203: E2E config-file persistence test script","description":"# What / why\n\n`savant` uses a local config file to remember the last programmed mapping for display and retry purposes.\n\nWe want a safe, repeatable manual script that verifies config-file handling without risking permanent changes:\n- back up any existing user config\n- write a known-good config\n- perform simple format checks\n- restore the user’s config on exit\n\nThis also acts as a “future self” sanity tool when changing config parsing/serialization.\n\n# Scope\n\nAdd a manual script:\n- `tests/e2e_config.sh`\n\nScript requirements:\n- determine config base path correctly:\n  - macOS: `~/Library/Application Support`\n  - otherwise: `$XDG_CONFIG_HOME` or `~/.config`\n- back up existing `pedals.conf` to a timestamped backup under `tests/logs/`\n- write a known-good config (`cmd+c`, `cmd+a`, `cmd+v`)\n- validate the format (presence of `left=`, `middle=`, `right=`)\n- restore previous config on exit (trap)\n\n# Logging requirements\n\n- write a timestamped log under `tests/logs/`\n- log the commands executed and high-level outcomes\n\n# Acceptance criteria\n\n- Script never permanently clobbers user config; it restores on exit.\n- Format checks are explicit and logged.\n- Script provides optional manual verification instructions for `savant info` visualization.\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:44:38.506772-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:51:52.999527-05:00","closed_at":"2026-01-25T20:55:29.869426-05:00","close_reason":"Added tests/e2e_config.sh: safe config-file script with backup/restore, basic format checks, and macOS-aware config path.","labels":["e2e","phase4","test"],"dependencies":[{"issue_id":"savant_elite_rust-3cr","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.602836-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-3cr","depends_on_id":"savant_elite_rust-yma","type":"blocks","created_at":"2026-01-25T23:54:03.420879-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-4eo","title":"BEAD-001: Empty/malformed key action input validation","description":"# What / why\n\n`KeyAction::from_string()` is the single parser for user-facing key-action strings like `cmd+c` or `ctrl+shift+f12`. This parser is hit by:\n- `savant program --left/--middle/--right ...`\n- any future feature that accepts key-action strings\n\nBefore this bead, malformed inputs produced **confusing, low-signal errors**:\n- `\"\"` → `Unknown key: \"\"` (looks like an internal bug)\n- `\"+\"` → split into empty tokens → `Unknown modifier: \"\"`\n- `\"shift+\"` → `Unknown key: \"\"`\n\nThis is a UX footgun: users don’t know what they did wrong, and the fix (“don’t start/end with `+` / don’t leave it blank”) is easy.\n\n# Scope\n\nTighten parsing validation for the following classes of invalid input:\n\n1. **Empty / whitespace-only**: `\"\"`, `\"   \"`\n2. **Leading or trailing plus**: `\"+c\"`, `\"cmd+\"`\n3. **Consecutive plus / empty component**: `\"cmd++c\"` and variants like `\"cmd + + c\"`\n\nOut of scope:\n- supporting multi-key macros (hardware limitation)\n- adding new key names (handled by `usb_hid::parse_key_name`)\n\n# Design / approach\n\nValidation should happen **before** any device operations so:\n- CLI arg validation works even when no hardware is connected\n- errors are deterministic and testable\n\nImplementation rules:\n- `trim()` the full string first\n- reject empty input early with a direct error (no “Unknown …”)\n- reject leading/trailing `+` (these always imply empty token)\n- reject `\"++\"` as a fast-path; also reject any token that becomes empty after trimming (covers `\"cmd + + c\"`)\n- keep the “last token is key; prior tokens are modifiers” contract\n\n# Testing\n\nCovered by unit tests:\n- BEAD-101: empty + whitespace-only input\n- BEAD-102: malformed plus cases (leading/trailing/only-plus/double-plus)\n\nAlso implicitly validated by CLI integration tests in BEAD-201 (because `program --dry-run` parses actions before touching hardware).\n\n# Acceptance criteria\n\n- `KeyAction::from_string(\"\")` and `KeyAction::from_string(\"   \")` return an error that mentions **cannot be empty**.\n- `KeyAction::from_string(\"+c\")`, `KeyAction::from_string(\"cmd+\")`, `KeyAction::from_string(\"+\")` return an error that mentions **cannot start or end with '+'**.\n- `KeyAction::from_string(\"cmd++c\")` returns an error that clearly indicates an **empty modifier / consecutive '+'**.\n- Valid inputs remain valid and unchanged (`cmd+c`, `ctrl+shift+alt+f12`, etc.).\n\n# Related beads\n\n- Validated by: BEAD-101, BEAD-102\n- Feeds into: BEAD-020 (disconnect hardening relies on robust early validation)\n\n","status":"closed","priority":0,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":30,"created_at":"2026-01-25T18:52:12.47601-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:46:20.477883-05:00","closed_at":"2026-01-25T18:54:24.510782-05:00","close_reason":"Fixed: Added input validation for empty, whitespace, leading/trailing +, and consecutive +","labels":["critical","input-validation","phase1"],"dependencies":[{"issue_id":"savant_elite_rust-4eo","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:40.990985-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-4ie","title":"Add shell completion scripts (zsh/bash/fish)","description":"# What / Why\n\nShell completions are a table-stakes feature for mature CLIs. They enable:\n\n- **Discoverability**: Users type `savant \u003ctab\u003e` and see all available commands\n- **Reduced errors**: Tab-completing key names prevents typos\n- **Faster workflow**: No need to remember exact syntax\n\nWithout completions, users must memorize command names or constantly run `--help`.\n\n# Background\n\nclap (our CLI parser) has built-in completion generation via `clap_complete`. This means:\n- Near-zero custom code needed\n- Completions stay in sync with actual CLI structure\n- Support for zsh, bash, fish, powershell, elvish\n\n# Scope\n\n## Deliverables\n\n1. **Completion generation subcommand**: `savant completions \u003cshell\u003e` outputs completion script\n2. **Shell support**: zsh, bash, fish (macOS defaults + common alternatives)\n3. **Documentation**: README section on how to install completions\n4. **Installer integration**: Optional completion install in `install.sh`\n\n## What gets completed\n\nCommands:\n- `savant \u003ctab\u003e` → shows `info`, `status`, `program`, `monitor`, `raw-cmd`, `probe`, `completions`\n\nSubcommand arguments:\n- `savant program --\u003ctab\u003e` → shows `--left`, `--middle`, `--right`, `--dry-run`, `--monitor`\n\nKey names (stretch goal):\n- `savant program --left \u003ctab\u003e` → shows common key names (this requires custom completer)\n\n# Design\n\n## Implementation approach\n\n1. Add `clap_complete` to dependencies\n2. Add `Completions` subcommand that takes shell type\n3. Generate and print completion script to stdout\n4. User pipes to appropriate location\n\n## Example usage\n\n```bash\n# Generate zsh completions\nsavant completions zsh \u003e ~/.zfunc/_savant\n\n# Generate bash completions  \nsavant completions bash \u003e /usr/local/etc/bash_completion.d/savant\n\n# Generate fish completions\nsavant completions fish \u003e ~/.config/fish/completions/savant.fish\n```\n\n## Code structure\n\n```rust\n#[derive(Subcommand)]\nenum Commands {\n    // ... existing commands ...\n    \n    /// Generate shell completion scripts\n    Completions {\n        /// Shell to generate completions for\n        #[arg(value_enum)]\n        shell: clap_complete::Shell,\n    },\n}\n```\n\n# Testing\n\n## Automated\n\n- Unit test: `completions` subcommand exists and accepts valid shell types\n- Integration test: `savant completions zsh` produces non-empty output\n- Integration test: `savant completions invalid` fails gracefully\n\n## Manual\n\n- Install zsh completions, verify `savant \u003ctab\u003e` works\n- Verify `savant program --\u003ctab\u003e` shows flags\n\n# Acceptance Criteria\n\n- [ ] `savant completions zsh` outputs valid zsh completion script\n- [ ] `savant completions bash` outputs valid bash completion script\n- [ ] `savant completions fish` outputs valid fish completion script\n- [ ] `savant completions --help` explains usage\n- [ ] README documents completion installation\n- [ ] No regression in existing functionality\n\n# Dependencies\n\nNone - this is independent of other features.\n\n# Estimated Effort\n\nSmall-medium: clap_complete does the heavy lifting. Main work is integration and documentation.\n\n# References\n\n- clap_complete docs: https://docs.rs/clap_complete/\n- Similar implementations: ripgrep, fd, bat all use this pattern","status":"closed","priority":1,"issue_type":"feature","assignee":"GrayForge","created_at":"2026-01-26T13:16:22.679324-05:00","created_by":"jemanuel","updated_at":"2026-01-26T20:26:33.606508-05:00","closed_at":"2026-01-26T20:26:33.606508-05:00","close_reason":"Implemented completions subcommand with zsh/bash/fish/powershell/elvish support. All 89 tests pass (47 unit + 42 integration).","dependencies":[{"issue_id":"savant_elite_rust-4ie","depends_on_id":"savant_elite_rust-gge","type":"blocks","created_at":"2026-01-26T13:16:26.654869-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-4ie","depends_on_id":"savant_elite_rust-gge","type":"relates-to","created_at":"2026-01-26T13:16:26.654869-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-4vu","title":"E2E test script: doctor command diagnostics","description":"# E2E test script: doctor command diagnostics\n\n## What\n\nCreate E2E shell script that tests the doctor command output and JSON format.\n\n## Tests to Implement\n\n1. Doctor runs successfully\n2. Doctor shows version info\n3. Doctor shows platform info\n4. Doctor JSON output is valid\n5. Doctor JSON has all check types\n6. Doctor summary counts are correct\n\n## Key Validations\n\n```bash\n# Doctor runs\nsavant doctor\n\n# JSON structure\nsavant --json doctor | jq -e \".version and .platform and .checks\"\n\n# All check types present\nsavant --json doctor | jq -e \".checks | map(.name) | contains([\\\"binary\\\", \\\"platform\\\", \\\"device\\\", \\\"config\\\", \\\"profiles\\\"])\"\n\n# Summary math is correct\nsavant --json doctor | jq -e \".summary.total == (.summary.passed + .summary.warnings + .summary.failed)\"\n```\n\n## Dependencies\n\n- savant_elite_rust-1w8 (E2E infrastructure)\n- jq for JSON validation\n\n## Acceptance Criteria\n\n- [ ] Doctor runs without crashing\n- [ ] JSON output is valid\n- [ ] All check types present\n- [ ] Summary counts add up correctly\n- [ ] Platform-appropriate results","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:21:10.236547-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:21:10.236547-05:00","dependencies":[{"issue_id":"savant_elite_rust-4vu","depends_on_id":"savant_elite_rust-1w8","type":"blocks","created_at":"2026-01-27T15:23:17.419893-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-4vu","depends_on_id":"savant_elite_rust-54y","type":"blocks","created_at":"2026-01-27T15:23:18.411241-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-51c","title":"BEAD-303: Update CI to run integration tests","description":"# What / why\n\nCI should provide high-signal feedback that the project is healthy:\n- unit tests (pure logic)\n- integration tests (CLI behavior)\n\nBecause this is a macOS-only project, CI should run on macOS runners.\n\n# Scope\n\nUpdate `.github/workflows/ci.yml` so CI:\n- runs `cargo test`\n- makes integration test output easy to spot (separate step/job is fine)\n- does not attempt hardware-dependent scripts\n\n# Acceptance criteria\n\n- CI runs on macOS and passes with:\n  - unit tests in `src/main.rs`\n  - integration tests in `tests/cli_validation.rs`\n- CI output is readable (failures clearly attributed to unit vs integration).\n\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T20:34:26.881343-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:52:17.676566-05:00","closed_at":"2026-01-25T20:35:49.752112-05:00","close_reason":"CI workflow updated to split test steps: unit tests (21) and E2E CLI tests (33) now run separately for clearer output","labels":["ci","infra","phase5"],"dependencies":[{"issue_id":"savant_elite_rust-51c","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.044593-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-51c","depends_on_id":"savant_elite_rust-qvt","type":"blocks","created_at":"2026-01-25T23:54:03.519638-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-51c","depends_on_id":"savant_elite_rust-wyy","type":"blocks","created_at":"2026-01-25T23:54:03.567342-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-54y","title":"Create test fixture files","description":"# Create test fixture files\n\n## What\n\nCreate a set of test fixture files for use in unit and integration tests.\n\n## Directory Structure\n\n```\ntests/fixtures/\n├── valid/\n│   ├── basic.conf           # left=cmd+c, middle=cmd+a, right=cmd+v\n│   ├── all_modifiers.conf   # Uses ctrl+shift+alt+cmd combinations\n│   ├── function_keys.conf   # Uses F1-F12\n│   ├── special_keys.conf    # Uses enter, space, tab, etc.\n│   └── with_whitespace.conf # Extra whitespace, blank lines\n├── invalid/\n│   ├── missing_left.conf\n│   ├── missing_middle.conf\n│   ├── missing_right.conf\n│   ├── invalid_key.conf     # left=cmd+notakey\n│   ├── invalid_modifier.conf # left=hyper+a\n│   ├── malformed_syntax.conf # Missing = sign\n│   ├── empty.conf\n│   └── newline_injection.conf\n└── edge_cases/\n    ├── equals_in_value.conf  # left=cmd+=\n    ├── duplicate_keys.conf   # left appears twice\n    ├── unknown_fields.conf   # Has extra fields\n    └── max_length_name.conf  # 64 char profile name test\n```\n\n## Fixture Contents\n\n### valid/basic.conf\n```\nleft=cmd+c\nmiddle=cmd+a\nright=cmd+v\n```\n\n### valid/all_modifiers.conf\n```\nleft=ctrl+shift+alt+cmd+a\nmiddle=ctrl+b\nright=shift+c\n```\n\n### invalid/missing_left.conf\n```\nmiddle=cmd+a\nright=cmd+v\n```\n\n### invalid/malformed_syntax.conf\n```\nleft cmd+c\nmiddle=cmd+a\nright=cmd+v\n```\n\n## Usage\n\nTests can reference fixtures via:\n```rust\nlet fixture = include_str!(\"../tests/fixtures/valid/basic.conf\");\n```\n\nOr in shell scripts:\n```bash\nFIXTURES=\"$SCRIPT_DIR/../fixtures\"\nsavant config check \"$FIXTURES/valid/basic.conf\"\n```\n\n## Acceptance Criteria\n\n- [ ] All fixture files created\n- [ ] Valid fixtures pass savant config check\n- [ ] Invalid fixtures fail as expected\n- [ ] Edge cases documented","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:21:44.006554-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:21:44.006554-05:00"}
{"id":"savant_elite_rust-5hv","title":"Integration tests for automatic config backup feature","description":"# Test bead\n\nAutomated tests for the feature.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel","updated_at":"2026-01-26T14:30:00-05:00","dependencies":[{"issue_id":"savant_elite_rust-5hv","depends_on_id":"savant_elite_rust-1hk","type":"blocks","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-5iu","title":"BEAD-005: Negative interface number accepted","description":"# What / why\n\n`raw-cmd` accepts `--interface` to select a specific HID interface number.\n\nUSB/HID interface numbers are inherently non-negative and practically fit in a byte (`u8`).\n\nBefore this bead, clap parsed `--interface` as `i32` with no range validation. That allowed nonsense inputs like `--interface -1`.\n\nEven though a negative interface is unlikely to do damage (it won’t match any real interface), it creates unnecessary confusion:\n- users don’t get immediate feedback that the input is invalid\n- future refactors could accidentally cast and mis-handle negative values\n\n# Scope\n\n- Add clap-level range validation for `--interface` to restrict it to `[0, 255]`.\n\nOut of scope:\n- changing how interfaces are discovered\n\n# Design / approach\n\nUse clap’s `value_parser` range constraint:\n\n```rust\n#[arg(long, default_value = \"0\", value_parser = clap::value_parser!(i32).range(0..=255))]\ninterface: i32,\n```\n\nThis ensures invalid values never reach runtime logic.\n\n# Testing\n\nBecause this is a clap-level validation, it is best tested via CLI integration tests rather than unit tests:\n- BEAD-105 exists to record this intent.\n- BEAD-201 includes the actual assertions:\n  - negative interface rejected\n  - interface \u003e 255 rejected\n\n# Acceptance criteria\n\n- `savant raw-cmd --cmd b5 --interface -1` fails argument parsing.\n- `savant raw-cmd --cmd b5 --interface 256` fails argument parsing.\n- Values 0..=255 remain accepted.\n\n# Related beads\n\n- Validated by: BEAD-105 and BEAD-201\n\n","status":"closed","priority":3,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":10,"created_at":"2026-01-25T18:52:37.205971-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:47:30.369261-05:00","closed_at":"2026-01-25T18:57:29.185998-05:00","close_reason":"Fixed: Added clap value_parser range(0..=255) for interface number","labels":["input-validation","low","phase1"],"dependencies":[{"issue_id":"savant_elite_rust-5iu","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.427553-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-6g1","title":"Unit tests for PedalConfig edge cases","description":"# Unit tests for PedalConfig edge cases\n\n## What\n\nExpand unit test coverage for PedalConfig parsing and serialization edge cases.\n\n## Current Coverage\n\n- Basic roundtrip\n- Newline/CR rejection\n- Missing file\n- Partial file\n- Extra whitespace\n\n## Additional Test Cases to Add\n\n```rust\n#[test]\nfn pedal_config_parse_ignores_comments_style_lines() {\n    // Lines without = should be skipped, not cause errors\n    let content = \"# This is a comment\\nleft=cmd+c\\nmiddle=cmd+a\\nright=cmd+v\\n\";\n    let config = PedalConfig::parse(content).unwrap();\n    assert_eq!(config.left, \"cmd+c\");\n}\n\n#[test]\nfn pedal_config_parse_ignores_unknown_keys() {\n    let content = \"left=cmd+c\\nmiddle=cmd+a\\nright=cmd+v\\nunknown=foo\\nother=bar\\n\";\n    let config = PedalConfig::parse(content).unwrap();\n    assert_eq!(config.left, \"cmd+c\");\n}\n\n#[test]\nfn pedal_config_parse_last_wins_for_duplicates() {\n    let content = \"left=cmd+c\\nleft=cmd+z\\nmiddle=cmd+a\\nright=cmd+v\\n\";\n    let config = PedalConfig::parse(content).unwrap();\n    assert_eq!(config.left, \"cmd+z\"); // Last value wins\n}\n\n#[test]\nfn pedal_config_parse_handles_empty_lines_anywhere() {\n    let content = \"\\n\\nleft=cmd+c\\n\\nmiddle=cmd+a\\n\\n\\nright=cmd+v\\n\\n\";\n    let config = PedalConfig::parse(content).unwrap();\n    assert_eq!(config.left, \"cmd+c\");\n    assert_eq!(config.middle, \"cmd+a\");\n    assert_eq!(config.right, \"cmd+v\");\n}\n\n#[test]\nfn pedal_config_parse_handles_equals_in_value() {\n    // Value can contain = sign (e.g., \"left==\")\n    let content = \"left=cmd+=\\nmiddle=cmd+a\\nright=cmd+v\\n\";\n    let config = PedalConfig::parse(content).unwrap();\n    assert_eq!(config.left, \"cmd+=\");\n}\n\n#[test]\nfn pedal_config_serialize_produces_parseable_output() {\n    let config = PedalConfig {\n        left: \"ctrl+shift+a\".to_string(),\n        middle: \"cmd+b\".to_string(),\n        right: \"alt+c\".to_string(),\n    };\n    let serialized = config.serialize().unwrap();\n    let reparsed = PedalConfig::parse(\u0026serialized).unwrap();\n    assert_eq!(reparsed.left, config.left);\n    assert_eq!(reparsed.middle, config.middle);\n    assert_eq!(reparsed.right, config.right);\n}\n\n#[test]\nfn pedal_config_config_path_is_absolute() {\n    let path = PedalConfig::config_path();\n    assert!(path.is_absolute() || path.to_string_lossy().starts_with(\"~\"));\n}\n\n#[test]\nfn pedal_config_rejects_tab_in_value() {\n    let config = PedalConfig {\n        left: \"cmd+c\\tright=evil\".to_string(),\n        middle: \"cmd+a\".to_string(),\n        right: \"cmd+v\".to_string(),\n    };\n    // Tabs should NOT be rejected (only \\n and \\r are checked)\n    // This test documents the current behavior\n    assert!(config.serialize().is_ok());\n}\n```\n\n## Location\n\nAdd to `src/main.rs` in the `#[cfg(test)] mod tests` section.\n\n## Acceptance Criteria\n\n- [ ] Comment-style lines handled\n- [ ] Duplicate keys handled (last wins)\n- [ ] Empty lines anywhere handled\n- [ ] Equals sign in value handled\n- [ ] Round-trip serialization verified","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:18:49.332561-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:18:49.332561-05:00"}
{"id":"savant_elite_rust-6hu","title":"BEAD-004: Raw command data silently truncated","description":"# What / why\n\n`raw-cmd` is an expert-only escape hatch that lets us send arbitrary HID output reports for reverse engineering / debugging.\n\nInternally, we construct a fixed-size 36-byte buffer:\n- byte 0: report id (0)\n- byte 1: command byte\n- bytes 2..=35: payload bytes (max 34 bytes)\n\nBefore this bead, if the user provided more than 34 data bytes, we silently dropped the excess due to a bounds check in the copy loop.\n\nThis is dangerous even for “expert mode”:\n- it makes troubleshooting impossible (“why didn’t the device respond?”)\n- it hides mistakes (off-by-one, wrong protocol format)\n- it violates the principle “never silently truncate user input”\n\n# Scope\n\n- Add an explicit validation for raw data length.\n- If payload length exceeds 34 bytes, return an error describing:\n  - the provided length\n  - the maximum allowed length\n\nOut of scope:\n- changing the raw-cmd wire format or buffer size\n\n# Design / approach\n\nImplement a single source of truth:\n\n- Define `MAX_RAW_DATA_LEN: usize = 34` (because 36 total bytes minus report-id + cmd).\n- Validate `data_bytes.len() \u003c= MAX_RAW_DATA_LEN` before constructing the buffer.\n- Keep the copy loop as a defensive fallback, but it should never truncate anymore because the earlier check prevents it.\n\nImplementation reference: `SavantElite::raw_cmd` in `src/main.rs`.\n\n# Testing\n\n- Primary coverage is via integration tests (BEAD-201):\n  - `cli_raw_cmd_rejects_data_too_long` ensures clap+runtime rejects overlong payloads and keeps behavior stable.\n\nWe intentionally avoided a separate unit-level refactor just for this check (see BEAD-104).\n\n# Acceptance criteria\n\n- `savant raw-cmd --cmd b5 --data \u003chex\u003e` fails when decoded payload length \u003e 34.\n- Error message indicates the actual vs max sizes.\n- Valid inputs (≤ 34 bytes) behave the same as before.\n\n# Related beads\n\n- Validated by: BEAD-104 (decision recorded) + BEAD-201 (integration test)\n\n","status":"closed","priority":2,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":15,"created_at":"2026-01-25T18:52:37.14068-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:47:18.594686-05:00","closed_at":"2026-01-25T18:55:55.183355-05:00","close_reason":"Fixed: Added MAX_RAW_DATA_LEN validation (34 bytes) with clear error message","labels":["input-validation","medium","phase1"],"dependencies":[{"issue_id":"savant_elite_rust-6hu","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.072349-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-70s","title":"BEAD-107: Unit tests for USB HID key code coverage","description":"# What / why\n\n`usb_hid::parse_key_name()` is the lookup table from user-facing key strings (e.g. `\"a\"`, `\"f12\"`, `\"enter\"`) to HID keycodes.\n\nA single wrong mapping produces confusing user outcomes:\n- the pedal is programmed successfully but sends the wrong key\n- the user blames hardware or the tool\n\nSo we want broad table-coverage tests that catch accidental regressions.\n\n# Scope\n\nUnit tests should cover:\n- all letters a–z map to 0x04–0x1D\n- numbers 1–9 map to 0x1E–0x26 and 0 maps to 0x27\n- function keys f1–f12 map to 0x3A–0x45\n- case-insensitivity (`A` == `a`, `F12` == `f12`, etc.)\n\nAdditionally (useful guardrails):\n- common aliases (`enter`/`return`, `esc`/`escape`)\n- arrow keys\n- unknown keys return `None`\n\n# Test design\n\nPrefer loops for systematic coverage (reduces copy/paste mistakes), and include helpful assertion messages so failures pinpoint the broken mapping.\n\n# Acceptance criteria\n\n- Tests pass and cover the primary key families (letters/numbers/F-keys).\n- Tests fail if any mapping is changed accidentally.\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:34:33.432343-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:49.320608-05:00","closed_at":"2026-01-25T20:36:59.261142-05:00","close_reason":"Added 7 comprehensive unit tests for USB HID key code parsing: all letters, numbers, function keys, special keys, arrow keys, case insensitivity, and unknown key handling","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-70s","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.809421-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-764","title":"Update README with new features documentation","description":"# What / Why\n\nNew features need documentation in README.md so users can discover and use them.\n\n# Scope\n\n## Sections to add/update\n\n### Shell Completions\n```markdown\n## Shell Completions\n\nGenerate shell completions for faster command entry:\n\n\\`\\`\\`bash\n# Zsh (add to ~/.zshrc)\nsavant completions zsh \u003e ~/.zfunc/_savant\n\n# Bash\nsavant completions bash \u003e /usr/local/etc/bash_completion.d/savant\n\n# Fish\nsavant completions fish \u003e ~/.config/fish/completions/savant.fish\n\\`\\`\\`\n```\n\n### Key Reference\n```markdown\n## Key Reference\n\nList all valid key names:\n\n\\`\\`\\`bash\nsavant keys           # Human-readable list\nsavant keys --json    # Machine-readable\nsavant keys | grep f  # Search for keys\n\\`\\`\\`\n```\n\n### Presets\n```markdown\n## Quick Start with Presets\n\nGet productive immediately with built-in presets:\n\n\\`\\`\\`bash\nsavant preset --list              # See all presets\nsavant preset copy-paste          # Apply copy/paste preset\nsavant preset copy-paste --dry-run  # Preview without programming\n\\`\\`\\`\n\nAvailable presets:\n- \\`copy-paste\\` - cmd+c, cmd+a, cmd+v (copy/select/paste)\n- \\`undo-redo\\` - cmd+z, cmd+a, shift+cmd+z (undo/select/redo)\n- \\`browser\\` - cmd+[, cmd+t, cmd+] (back/new tab/forward)\n```\n\n### JSON Output\n```markdown\n## Scripting\n\nUse JSON output for automation:\n\n\\`\\`\\`bash\nsavant info --json | jq '.device.mode'\nsavant status --json | jq '.ready_to_program'\n\\`\\`\\`\n```\n\n### Verbose Mode\n```markdown\n## Troubleshooting\n\nEnable verbose output to see what's happening:\n\n\\`\\`\\`bash\nsavant program --left cmd+c -v    # See USB commands\nsavant info -v                     # See device details\n\\`\\`\\`\n```\n\n# Acceptance Criteria\n\n- [ ] Shell completions documented\n- [ ] Keys command documented\n- [ ] Presets documented\n- [ ] JSON output documented\n- [ ] Verbose mode documented\n- [ ] Examples are tested and work\n\n# Dependencies\n\n- Should be done after features are implemented\n- Validates all Phase 1 features","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T13:22:53.093277-05:00","created_by":"jemanuel","updated_at":"2026-01-26T13:22:53.093277-05:00","dependencies":[{"issue_id":"savant_elite_rust-764","depends_on_id":"savant_elite_rust-4ie","type":"blocks","created_at":"2026-01-26T13:22:58.885486-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-764","depends_on_id":"savant_elite_rust-d8p","type":"blocks","created_at":"2026-01-26T13:22:58.937356-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-764","depends_on_id":"savant_elite_rust-dz9","type":"blocks","created_at":"2026-01-26T13:22:58.996557-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-764","depends_on_id":"savant_elite_rust-prn","type":"blocks","created_at":"2026-01-26T13:22:59.055539-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-764","depends_on_id":"savant_elite_rust-rav","type":"blocks","created_at":"2026-01-26T13:22:59.118891-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-7gp","title":"Unit tests for profiles_dir and profile_path functions","description":"# Unit tests for profiles_dir and profile_path\n\n## What\n\nAdd unit tests for the path construction functions used by the profile system.\n\n## Current Coverage\n\nNo direct unit tests. Only tested implicitly.\n\n## Test Cases to Add\n\n```rust\n#[test]\nfn profiles_dir_is_under_config_dir() {\n    let dir = profiles_dir();\n    // Should be something like ~/.config/savant-elite/profiles/\n    assert!(dir.to_string_lossy().contains(\"savant-elite\"));\n    assert!(dir.to_string_lossy().contains(\"profiles\"));\n}\n\n#[test]\nfn profiles_dir_ends_with_profiles() {\n    let dir = profiles_dir();\n    assert_eq!(dir.file_name().unwrap().to_str().unwrap(), \"profiles\");\n}\n\n#[test]\nfn profile_path_appends_conf_extension() {\n    let path = profile_path(\"myprofile\");\n    assert!(path.to_string_lossy().ends_with(\".conf\"));\n}\n\n#[test]\nfn profile_path_uses_profile_name() {\n    let path = profile_path(\"testname\");\n    assert!(path.to_string_lossy().contains(\"testname.conf\"));\n}\n\n#[test]\nfn profile_path_is_under_profiles_dir() {\n    let path = profile_path(\"test\");\n    let dir = profiles_dir();\n    assert!(path.starts_with(\u0026dir));\n}\n\n#[test]\nfn profile_path_handles_hyphens_and_underscores() {\n    let path1 = profile_path(\"my-profile\");\n    let path2 = profile_path(\"my_profile\");\n    assert!(path1.to_string_lossy().contains(\"my-profile.conf\"));\n    assert!(path2.to_string_lossy().contains(\"my_profile.conf\"));\n}\n```\n\n## Location\n\nAdd to `src/main.rs` in the `#[cfg(test)] mod tests` section.\n\n## Acceptance Criteria\n\n- [ ] Path structure is correct\n- [ ] Extension is .conf\n- [ ] Paths are under the correct directory","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:18:05.594043-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:18:05.594043-05:00"}
{"id":"savant_elite_rust-7h5","title":"BEAD-020: Add USB disconnect detection during programming","description":"# What / why\n\nProgramming the Savant Elite is a multi-step USB operation:\n1. For each pedal (left/middle/right), send a `CMD_SET_KEY_MACRO` command.\n2. Send `CMD_SAVE_TO_EEPROM` to persist changes.\n\nA critical real-world failure mode is **USB disconnect mid-program**:\n- user accidentally unplugs the device\n- USB hub blips\n- macOS suspends/re-enumerates\n\nWithout explicit detection, the tool can:\n- emit confusing pipe/timeout errors\n- continue trying further commands\n- leave the user unsure what actually happened\n\nAlso, the hardware behavior matters:\n- SET_KEY_MACRO changes may be staged in RAM.\n- If the device is unplugged before EEPROM save, those changes are typically lost.\n\nSo the tool must handle disconnects explicitly and communicate the consequences clearly.\n\n# Scope\n\n- Detect device disappearance during the programming sequence.\n- Print a clear warning and next steps when it happens.\n- Do **not** continue sending further commands after a disconnect is detected.\n\nOut of scope:\n- guaranteeing atomic programming at the hardware level (the device protocol doesn’t provide it)\n\n# Design / approach\n\nKey idea: treat “device presence” as a first-class invariant while programming.\n\nImplementation sketch:\n- Record the device’s bus number + address at the start of programming.\n- After each pedal (and again before EEPROM save), check if the same bus/address is still present in `rusb::devices()`.\n  - If not present, assume disconnect/re-enumeration and abort.\n\nUX behaviors:\n- Before starting, print an explicit warning: keep device connected.\n- On detected disconnect:\n  - show a prominent warning box\n  - explain that pedal settings were only in RAM and were lost\n  - instruct the user to reconnect in PROGRAM mode and rerun `savant program`\n\nImportant nuance:\n- In a disconnect-abort path, do **not** write the local config file (because we explicitly tell the user the changes were lost).\n\n# Testing\n\nAutomated tests are not appropriate here because:\n- detection depends on real USB enumeration state\n- reproducing disconnect reliably in CI isn’t feasible\n\nManual validation:\n- Use `tests/e2e_hardware_sim.sh` (BEAD-202) for the normal program/monitor happy path.\n- Optional (risky) manual test: unplug during programming to confirm messaging. This should be clearly marked as potentially leaving the device in an unexpected state.\n\n# Acceptance criteria\n\n- If the device disappears during programming:\n  - the tool stops further programming immediately\n  - the user sees a clear “DEVICE DISCONNECTED” message\n  - the tool explains that changes were not saved to EEPROM and were lost\n  - the tool prints the exact next steps to recover\n\n","status":"closed","priority":1,"issue_type":"feature","assignee":"claude-opus-4.5","estimated_minutes":60,"created_at":"2026-01-25T18:53:04.082412-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:48:33.020451-05:00","closed_at":"2026-01-25T19:35:43.314684-05:00","close_reason":"Implemented USB disconnect detection: added pre-programming warning, device presence check after each pedal, and enhanced error messages for partial programming state","labels":["hardening","phase2"],"dependencies":[{"issue_id":"savant_elite_rust-7h5","depends_on_id":"savant_elite_rust-4eo","type":"blocks","created_at":"2026-01-25T18:53:04.086585-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-7h5","depends_on_id":"savant_elite_rust-bq1","type":"blocks","created_at":"2026-01-25T18:53:04.087526-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-7h5","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.197667-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-7sc","title":"BEAD-104: Unit tests for raw command data length validation","description":"# What / why\n\nOriginal plan intent:\n- Add a unit test that ensures raw-cmd rejects payloads \u003e 34 bytes (the fix in BEAD-004).\n\nDuring implementation we made a deliberate choice:\n- The validation is a simple length check.\n- We already have CLI integration tests (BEAD-201) that exercise the real command-line behavior.\n- Refactoring `raw_cmd` solely to expose a “unit-testable helper” would add code surface and complexity with minimal benefit.\n\nSo this bead acts as a **design record**: we consider BEAD-004’s behavior validated by integration tests.\n\n# Scope\n\n- Ensure there is durable test coverage that overlong raw-cmd payloads are rejected.\n\n# Where it is covered\n\n- BEAD-201 integration test:\n  - `cli_raw_cmd_rejects_data_too_long`\n\n# When to revisit\n\nConsider adding a true unit test if:\n- `raw_cmd` validation logic becomes more complex than a simple length check\n- we introduce additional raw command formats/parsing where unit tests provide better granularity\n\n","status":"closed","priority":2,"issue_type":"task","estimated_minutes":20,"created_at":"2026-01-25T18:52:49.344287-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:19.023492-05:00","closed_at":"2026-01-25T18:55:55.228348-05:00","close_reason":"Validation logic simple enough; covered by integration test BEAD-201","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-7sc","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.967191-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-7sc","depends_on_id":"savant_elite_rust-6hu","type":"validates","created_at":"2026-01-25T23:54:03.054339-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-83m","title":"BEAD-101: Unit tests for KeyAction empty string handling","description":"# What / why\n\nThis bead adds unit tests that lock in the desired UX for BEAD-001:\n- empty or whitespace-only key-action strings should produce a clear “cannot be empty” error.\n\nWe keep these as unit tests because:\n- they’re pure parsing logic (no hardware, deterministic)\n- they enforce error-message clarity at the source\n\n# Scope\n\nAdd unit tests for:\n- `KeyAction::from_string(\"\")`\n- `KeyAction::from_string(\"   \")`\n\n# Test design\n\nAssertions should:\n- ensure an error occurs\n- verify the error message contains a stable phrase (e.g., “cannot be empty”)\n\nAvoid overfitting to exact punctuation so small copy changes don’t cause churn.\n\n# Acceptance criteria\n\n- Tests pass on all platforms (no hardware requirements).\n- Error message contains “cannot be empty” (case-sensitive is fine as long as stable).\n\n# Related beads\n\n- Validates: BEAD-001\n\n","status":"closed","priority":1,"issue_type":"task","estimated_minutes":30,"created_at":"2026-01-25T18:52:49.154301-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:48.731759-05:00","closed_at":"2026-01-25T18:54:24.561159-05:00","close_reason":"Tests added in same commit as BEAD-001 fix","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-83m","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.397774-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-83m","depends_on_id":"savant_elite_rust-4eo","type":"validates","created_at":"2026-01-25T23:54:02.777809-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-86q","title":"E2E test script: config and profile management","description":"# E2E test script: config and profile management\n\n## What\n\nCreate E2E shell script that tests config file validation and profile management workflows.\n\n## Tests to Implement\n\n1. Config check with valid file\n2. Config check with invalid key  \n3. Config check with missing field\n4. Config check with nonexistent file\n5. Config check JSON output\n6. Config list (empty and populated)\n7. Profile save/show/load/delete workflow\n\n## Key Test Cases\n\n- Valid config passes validation\n- Invalid key names rejected\n- Missing required fields rejected  \n- JSON output validates with jq\n- Profile lifecycle works end-to-end\n\n## Dependencies\n\n- savant_elite_rust-1w8 (E2E infrastructure)\n- jq for JSON validation\n- Temp directory for isolation\n\n## Acceptance Criteria\n\n- [ ] Valid configs pass validation\n- [ ] Invalid configs fail with clear errors\n- [ ] Missing files handled gracefully\n- [ ] JSON output validates\n- [ ] Profile CRUD workflow tested","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:20:57.28163-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:20:57.28163-05:00","dependencies":[{"issue_id":"savant_elite_rust-86q","depends_on_id":"savant_elite_rust-1w8","type":"blocks","created_at":"2026-01-27T15:23:17.360827-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-86q","depends_on_id":"savant_elite_rust-54y","type":"blocks","created_at":"2026-01-27T15:23:18.343784-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-899","title":"CLI integration tests for full config workflow","description":"# CLI integration tests for full config workflow\n\n## What\n\nAdd integration tests that verify the complete config save/load/delete workflow, testing the interaction between commands.\n\n## Current Gap\n\nIndividual config subcommands are tested, but not the full workflow.\n\n## Test Cases to Add\n\n```rust\n// tests/cli_validation.rs\n\n// ============================================================================\n// Config Workflow Tests\n// ============================================================================\n\n#[test]\nfn cli_config_workflow_save_list_show_delete() {\n    use tempfile::tempdir;\n    use std::env;\n    \n    // Create a temp directory for config\n    let temp = tempdir().unwrap();\n    env::set_var(\"XDG_CONFIG_HOME\", temp.path());\n    \n    // First, we need a current config (simulate by creating pedals.conf)\n    let config_dir = temp.path().join(\"savant-elite\");\n    fs::create_dir_all(\u0026config_dir).unwrap();\n    fs::write(config_dir.join(\"pedals.conf\"), \"left=cmd+c\\nmiddle=cmd+a\\nright=cmd+v\\n\").unwrap();\n    \n    // 1. Save a profile\n    savant()\n        .args([\"config\", \"save\", \"testprofile\"])\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"Saved profile\"));\n    \n    // 2. List should show the profile\n    savant()\n        .args([\"config\", \"list\"])\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"testprofile\"));\n    \n    // 3. Show should display profile contents\n    savant()\n        .args([\"config\", \"show\", \"testprofile\"])\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"cmd+c\"));\n    \n    // 4. Delete (with force)\n    savant()\n        .args([\"config\", \"delete\", \"testprofile\", \"--force\"])\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"Deleted\"));\n    \n    // 5. List should no longer show it\n    savant()\n        .args([\"config\", \"list\"])\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"testprofile\").not());\n}\n\n#[test]\nfn cli_config_save_requires_existing_config() {\n    use tempfile::tempdir;\n    use std::env;\n    \n    // Fresh temp dir with no config\n    let temp = tempdir().unwrap();\n    env::set_var(\"XDG_CONFIG_HOME\", temp.path());\n    \n    savant()\n        .args([\"config\", \"save\", \"shouldfail\"])\n        .assert()\n        .failure()\n        .stdout(predicate::str::contains(\"No current configuration\"));\n}\n\n#[test]\nfn cli_config_save_prevents_overwrite_without_force() {\n    // Test that saving to existing profile fails without --force\n    // (Setup similar to above)\n}\n\n#[test]\nfn cli_config_load_dry_run_does_not_modify() {\n    // Verify --dry-run shows what would happen but doesn't change anything\n}\n```\n\n## Dependencies\n\nRequires tempfile fixtures setup.\n\n## Acceptance Criteria\n\n- [ ] Full save→list→show→delete workflow tested\n- [ ] Error cases for missing config tested\n- [ ] Overwrite protection tested\n- [ ] Dry-run behavior verified","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:19:14.548107-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:19:14.548107-05:00"}
{"id":"savant_elite_rust-8fb","title":"Integration tests for configurable timeout feature","description":"# What / Why\n\nConfigurable timeout needs automated testing to ensure:\n- Timeout flag is accepted\n- Timeout config is respected\n- Error messages mention timeout when relevant\n\n# Scope\n\n## Test cases\n\n1. **Timeout flag accepted**\n   - `savant program --timeout 5000` accepts flag\n   - `savant info --timeout 2000` accepts flag\n\n2. **Invalid timeout rejected**\n   - `savant program --timeout -1` gives clear error\n   - `savant program --timeout 0` gives clear error\n\n3. **Config file timeout**\n   - timeout value in config is respected\n\n# Acceptance Criteria\n\n- [ ] Tests verify timeout flag accepted\n- [ ] Tests verify invalid timeouts rejected with clear error\n- [ ] CI runs these tests","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T14:00:00-05:00","created_by":"jemanuel","updated_at":"2026-01-27T12:35:49.442256-05:00","closed_at":"2026-01-27T12:35:49.442256-05:00","close_reason":"Implemented --timeout flag with 100ms-600000ms range, verbose logging, and 8 integration tests","dependencies":[{"issue_id":"savant_elite_rust-8fb","depends_on_id":"savant_elite_rust-gn0","type":"blocks","created_at":"2026-01-26T14:00:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-9dr","title":"BEAD-202: E2E hardware test script (manual)","description":"# What / why\n\nSome critical behaviors cannot be validated in CI because they require real hardware:\n- device detection across Play vs Program modes\n- actual EEPROM programming\n- monitor output correctness\n\nTo make manual verification repeatable and auditable, we want a guided script that:\n- runs the right commands in the right order\n- prompts for the required physical switch/replug steps\n- produces a timestamped log artifact\n\n# Scope\n\nAdd a manual E2E script:\n- `tests/e2e_hardware_sim.sh`\n\nThe script should:\n- build `target/release/savant` if missing\n- write logs to `tests/logs/` (timestamped filename)\n- run a baseline set of commands that don’t require hardware\n- guide the user through connecting hardware and switching modes\n\n# Logging requirements\n\nLogs should be self-explanatory:\n- include timestamps\n- include the exact command line executed\n- capture stdout/stderr\n- include “manual check” prompts where a human must verify behavior\n\n# Safety / user considerations\n\n- “Real programming” writes to EEPROM; script should explicitly prompt before doing it.\n- `savant program` may require `sudo` on macOS.\n- `savant monitor` requires Input Monitoring permission for the terminal.\n\n# Acceptance criteria\n\n- Running `tests/e2e_hardware_sim.sh` produces a log file under `tests/logs/`.\n- The script guides a full happy-path flow: Play → Program → program → Play → monitor.\n- The script is safe-by-default (explicit prompt before real programming).\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:44:34.303495-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:51:34.603309-05:00","closed_at":"2026-01-25T20:55:25.983352-05:00","close_reason":"Added tests/e2e_hardware_sim.sh: guided, logged manual hardware verification flow for status/info/program/monitor.","labels":["e2e","manual","phase4","test"],"dependencies":[{"issue_id":"savant_elite_rust-9dr","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.654298-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-9dr","depends_on_id":"savant_elite_rust-yyo","type":"blocks","created_at":"2026-01-25T23:54:03.37605-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-9fm","title":"BEAD-003: Auto-monitor infinite wait loop with no timeout","description":"# What / why\n\n`savant program` has an optional `--monitor` flow that helps the user immediately test their newly programmed mappings.\n\nThe hardware reality:\n- To program, the device must be in **PROGRAM** mode (different PID).\n- To *monitor key output*, the device must be in **PLAY** mode.\n- Switching modes requires flipping a physical switch and replugging.\n\nBefore this bead, the auto-monitor handoff waited in a tight loop for the play-mode HID interface with **no timeout**. If the user forgot to flip the switch, the program appeared “hung” forever.\n\nThis is a UX failure mode:\n- users don’t know if the tool is stuck or if they did something wrong\n- you lose the “trust moment” right after programming\n\n# Scope\n\n- Add a **hard timeout** (default: 60s) for the “waiting for play mode” loop.\n- Print periodic reminders while waiting.\n- On timeout, exit the auto-monitor path gracefully with actionable instructions.\n\nOut of scope:\n- fully automating mode switching (hardware switch prevents it)\n\n# Design / approach\n\nImplement a user-friendly wait loop:\n- Track `wait_start` and `timeout`.\n- Sleep in small increments (e.g., 500ms) and retry opening the keyboard interface.\n- Print a reminder every ~10s with remaining seconds.\n- If the timeout is exceeded:\n  - print a clear timeout message\n  - instruct the user to run `savant monitor` manually after switching modes\n  - return `Ok(())` so the user isn’t stuck with an “error” for a normal human mistake\n\nImplementation reference: `src/main.rs` auto-monitor wait loop near the `--monitor` path (look for “Timeout! Device not detected …”).\n\n# Testing\n\nAutomated tests are intentionally **not** added here:\n- the behavior depends on real HID device availability and wall-clock time.\n\nValidation should be done via the manual hardware script:\n- BEAD-202 (`tests/e2e_hardware_sim.sh`) can be used to simulate “never switch back to Play mode” and confirm:\n  - reminders print\n  - timeout triggers\n  - program exits without hanging\n\n# Acceptance criteria\n\n- If `--monitor` is requested and the device never appears in Play mode, the CLI prints:\n  - periodic “still waiting” reminders\n  - a timeout message after 60 seconds\n  - a clear next step (“run `savant monitor` manually after switching modes”)\n- The CLI does not hang indefinitely.\n\n# Related beads\n\n- Complements: BEAD-202 (manual E2E script captures this flow)\n\n","status":"closed","priority":1,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":30,"created_at":"2026-01-25T18:52:37.078133-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:47:03.417811-05:00","closed_at":"2026-01-25T18:57:29.135857-05:00","close_reason":"Fixed: Added 60s timeout with 15s periodic reminders to auto-monitor wait loop","labels":["high","phase1","ux"],"dependencies":[{"issue_id":"savant_elite_rust-9fm","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.448547-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-9k5","title":"E2E test script: hardware tests (optional)","description":"# E2E test script: hardware tests (optional)\n\n## What\n\nCreate E2E shell script for testing with actual Savant Elite hardware. This script should skip gracefully if no device is connected.\n\n## Tests to Implement (when device present)\n\n1. Device detection in play mode\n2. Device detection in program mode\n3. Monitor mode captures keypresses\n4. Program mode writes configuration\n5. Verify programmed keys work\n\n## Script Structure\n\n```bash\n#\\!/bin/bash\n# Check for device first\nif \\! savant status 2\u003e/dev/null | grep -q \"Found\"; then\n    log_warn \"No device connected - skipping hardware tests\"\n    exit 0  # Skip, dont fail\nfi\n\n# Device is connected, run hardware tests\n# ...\n```\n\n## Safety Considerations\n\n- Never auto-run program tests in CI\n- Require explicit flag: --enable-hardware-tests\n- Always verify current config before modifying\n- Provide restore instructions\n\n## Dependencies\n\n- savant_elite_rust-1w8 (E2E infrastructure)\n- Physical Savant Elite device\n\n## Acceptance Criteria\n\n- [ ] Script skips gracefully without device\n- [ ] Device detection works\n- [ ] Monitor captures real keypresses\n- [ ] Program mode tested (manual flag required)\n- [ ] Safety warnings shown","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-27T15:21:25.398315-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:21:25.398315-05:00","dependencies":[{"issue_id":"savant_elite_rust-9k5","depends_on_id":"savant_elite_rust-1w8","type":"blocks","created_at":"2026-01-27T15:23:17.488536-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-9k5","depends_on_id":"savant_elite_rust-54y","type":"blocks","created_at":"2026-01-27T15:23:18.473431-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-atl","title":"Integration tests for config profiles feature","description":"# Test bead\n\nAutomated tests for the feature.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel","updated_at":"2026-01-27T12:05:13.125469-05:00","closed_at":"2026-01-27T12:05:13.125469-05:00","close_reason":"Added 12 integration tests for config profiles","dependencies":[{"issue_id":"savant_elite_rust-atl","depends_on_id":"savant_elite_rust-ewe","type":"blocks","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-b09","title":"Add 'savant doctor' command for system diagnostics","description":"# What / Why\n\nmacOS has complex permission requirements that often cause mysterious failures:\n- **Input Monitoring permission** - Required for `savant monitor` to read HID events\n- **USB access** - May require sudo for certain operations\n- **Driver conflicts** - Other software might grab the device\n\nWhen something doesn't work, users have no idea why. They see:\n```\nError: Failed to open device\n```\n\nBut the actual problem might be:\n- Terminal doesn't have Input Monitoring permission\n- Another app has the device open\n- USB hub is not providing enough power\n- Device is in wrong mode\n\nA `savant doctor` command diagnoses these issues proactively.\n\n# Background\n\nThis pattern is used by many tools:\n- `brew doctor` - Check Homebrew installation health\n- `flutter doctor` - Verify Flutter development environment\n- `rustup check` - Check Rust toolchain status\n\nUsers expect a diagnostic command that tells them what's wrong and how to fix it.\n\n# Scope\n\n## Deliverables\n\n1. **`savant doctor` command** - Run all diagnostics\n2. **Permission checks** - Input Monitoring, USB access\n3. **Device checks** - Detection, mode, driver conflicts\n4. **Config checks** - File exists, valid format\n5. **Actionable output** - Clear pass/fail with fix instructions\n\n## Checks to perform\n\n### 1. Device Detection\n```\n✓ Savant Elite device detected\n  Mode: PLAY\n  VID: 0x05F3, PID: 0x030C\n```\nor\n```\n✗ No Savant Elite device found\n  → Connect the device via USB\n  → Try a different USB port\n  → Check if another app has the device open\n```\n\n### 2. Device Mode\n```\n✓ Device is in PROGRAMMING mode (ready to program)\n```\nor\n```\n⚠ Device is in PLAY mode\n  → To program: flip switch to Program, replug USB\n  → To monitor: this mode is correct\n```\n\n### 3. Input Monitoring Permission (macOS)\n```\n✓ Input Monitoring permission granted for Terminal\n```\nor\n```\n✗ Input Monitoring permission not detected\n  → Open System Preferences → Security \u0026 Privacy → Privacy → Input Monitoring\n  → Add your terminal app (Terminal, iTerm2, etc.)\n  → Restart the terminal\n```\n\n### 4. USB Access\n```\n✓ USB device accessible without sudo\n```\nor\n```\n⚠ USB access may require elevated privileges\n  → Try running with: sudo savant program ...\n  → Or check if SIP is preventing access\n```\n\n### 5. Config File\n```\n✓ Config file exists and is valid\n  Path: ~/.config/savant-elite/pedals.conf\n  Config: left=cmd+c, middle=cmd+a, right=cmd+v\n```\nor\n```\n⚠ Config file not found (this is OK for first-time use)\n  Path: ~/.config/savant-elite/pedals.conf\n  → Run 'savant program' to create a configuration\n```\n\n### 6. Binary Health\n```\n✓ savant version 0.1.3\n✓ Running on macOS 14.2 (Darwin)\n✓ Architecture: arm64\n```\n\n## Output format\n\n```\n$ savant doctor\n\nChecking savant-elite installation...\n\nBinary:\n  ✓ savant version 0.1.3\n  ✓ macOS 14.2 (arm64)\n\nDevice:\n  ✓ Savant Elite detected\n  ✓ Mode: PLAY (VID=0x05F3, PID=0x030C)\n\nPermissions:\n  ✗ Input Monitoring permission not detected\n    → Open System Preferences → Security \u0026 Privacy → Privacy\n    → Add your terminal app to Input Monitoring\n    → Restart your terminal\n\nConfig:\n  ✓ Config file valid: ~/.config/savant-elite/pedals.conf\n\nSummary: 1 issue found\n\nTo monitor pedal input, fix the Input Monitoring permission issue above.\n```\n\n# Design\n\n## Implementation approach\n\n1. Add `Doctor` subcommand\n2. Define check trait/struct for each diagnostic\n3. Run checks in order, collect results\n4. Print formatted output\n5. Exit code: 0 if all pass, 1 if warnings, 2 if errors\n\n## macOS-specific checks\n\nInput Monitoring permission is tricky to detect programmatically. Options:\n- Try to open HID device, check for permission error\n- Check TCC database (requires elevated access)\n- Just attempt and report what happens\n\nPragmatic approach: attempt the operation, interpret the error.\n\n# Testing\n\n## Automated\n\n- Integration test: `savant doctor` runs without crashing\n- Integration test: exit code reflects check results\n- Integration test: output contains expected sections\n\n## Manual\n\n- Run on fresh macOS install, verify permission issues detected\n- Run with device disconnected, verify detection message\n- Run with device in wrong mode, verify mode message\n\n# Acceptance Criteria\n\n- [ ] `savant doctor` runs comprehensive diagnostics\n- [ ] Each check has clear pass/warn/fail indicator\n- [ ] Failed checks include actionable fix instructions\n- [ ] Exit code reflects overall health (0=ok, 1=warn, 2=error)\n- [ ] Works without device connected (shows appropriate message)\n- [ ] macOS permission issues are detected and explained\n\n# Dependencies\n\n- Should work with JSON output (`--json`) for scripting\n- Should work with verbose mode (`-v`) for debugging\n\n# Considerations\n\n## Why not just better error messages?\n\nDoctor provides proactive diagnosis:\n- Run before problems occur\n- Check multiple things at once\n- Give complete picture of system health\n\nError messages only trigger on failure.\n\n## What about Linux/Windows?\n\nTool is macOS-only (IOKit requirement). Doctor should reflect this:\n```\n✗ Unsupported platform: Linux\n  → savant-elite requires macOS (uses IOKit for USB)\n```\n\n# Estimated Effort\n\nMedium-large: Requires understanding macOS permission system, implementing multiple checks, designing clear output.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-26T13:19:59.786685-05:00","created_by":"jemanuel","updated_at":"2026-01-27T12:29:37.201968-05:00","closed_at":"2026-01-27T12:29:37.201968-05:00","close_reason":"Implemented savant doctor command with 6 diagnostic checks: binary, platform, device, config, profiles, permissions. Added 6 integration tests."}
{"id":"savant_elite_rust-bq1","title":"BEAD-002: Config file newline injection vulnerability","description":"# What / why\n\n`PedalConfig` persists the most recently programmed pedal mappings to disk so the CLI can display configuration later (e.g. `savant info` can show a visualization even though the device EEPROM is effectively write-only).\n\nThe on-disk format is a simple line-based key/value file:\n\n```\nleft=cmd+c\nmiddle=cmd+a\nright=cmd+v\n```\n\nBefore this bead, the save path accepted arbitrary strings for each value and wrote them verbatim. If a value contained a newline, the file structure could be corrupted.\n\nThis matters because it creates a **config injection / corruption** vector:\n- A user (or script) can supply a key action containing `\\n` or `\\r` via shell quoting (e.g. `$'cmd+c\\nright=evil'`).\n- The config file now contains extra lines that the loader will interpret as additional keys.\n- Result: `PedalConfig::load()` can misparse, and the UI may display incorrect mappings (or fall back to “unknown”).\n\nEven though this is “just” a local config file, this is still worth fixing because:\n- it breaks UX and trust in `savant info`\n- it’s an easy mistake to make when piping inputs\n- it’s a low-effort hardening win\n\n# Scope\n\n- Reject any key-action value containing `\\n` or `\\r` during serialization/saving.\n- Keep parsing behavior permissive (ignore unknown keys) but ensure we never *write* malformed structure.\n\nOut of scope:\n- escaping newlines (we want to keep the format simple and unambiguous)\n\n# Design / approach\n\nImplement the validation in the lowest-friction place:\n- In `PedalConfig::serialize()` (called by `save_to()` / `save()`), iterate over `left`, `middle`, `right`.\n- If a value contains `\\n` or `\\r`, return an error with the field name (`left`/`middle`/`right`) so the user knows what to fix.\n\nThis ensures:\n- *all* save paths are protected (including tests)\n- callers don’t need to remember to validate separately\n\n# Testing\n\nUnit tests (BEAD-103):\n- `pedal_config_rejects_newline_in_value`\n- `pedal_config_rejects_carriage_return_in_value`\n\n# Acceptance criteria\n\n- `PedalConfig::save()` fails with a clear error if any value contains `\\n` or `\\r`.\n- The error message identifies which field is invalid.\n- Normal values (`cmd+c`, etc.) are unaffected.\n\n# Related beads\n\n- Validated by: BEAD-103\n- Related UX: BEAD-203 (manual config script assumes the file format is stable)\n\n","status":"closed","priority":1,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":15,"created_at":"2026-01-25T18:52:20.323998-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:46:39.493068-05:00","closed_at":"2026-01-25T18:55:13.967001-05:00","close_reason":"Fixed: Added validation to reject newlines/carriage returns in PedalConfig values","labels":["high","input-validation","phase1","security"],"dependencies":[{"issue_id":"savant_elite_rust-bq1","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.499423-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-br3","title":"Unit tests for usb_hid helper functions (key_name, modifier_names)","description":"# Unit tests for usb_hid helper functions\n\n## What\n\nAdd comprehensive unit tests for the USB HID helper functions that convert codes to human-readable names.\n\n## Functions to Test\n\n- `usb_hid::key_name(code: u8) -\u003e \u0026'static str`\n- `usb_hid::modifier_names(mods: u8) -\u003e Vec\u003c\u0026'static str\u003e`\n\n## Test Cases to Add\n\n```rust\n// key_name tests\n#[test]\nfn key_name_returns_letters() {\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_A), \"A\");\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_Z), \"Z\");\n}\n\n#[test]\nfn key_name_returns_numbers() {\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_0), \"0\");\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_9), \"9\");\n}\n\n#[test]\nfn key_name_returns_function_keys() {\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_F1), \"F1\");\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_F12), \"F12\");\n}\n\n#[test]\nfn key_name_returns_special_keys() {\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_ENTER), \"Enter\");\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_SPACE), \"Space\");\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_TAB), \"Tab\");\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_ESC), \"Esc\");\n}\n\n#[test]\nfn key_name_returns_arrow_keys() {\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_LEFT), \"Left\");\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_RIGHT), \"Right\");\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_UP), \"Up\");\n    assert_eq!(usb_hid::key_name(usb_hid::KEY_DOWN), \"Down\");\n}\n\n#[test]\nfn key_name_returns_unknown_for_invalid() {\n    assert!(usb_hid::key_name(0xFF).contains(\"0x\") || \n            usb_hid::key_name(0xFF).to_lowercase().contains(\"unknown\"));\n}\n\n// modifier_names tests\n#[test]\nfn modifier_names_returns_empty_for_zero() {\n    assert!(usb_hid::modifier_names(0).is_empty());\n}\n\n#[test]\nfn modifier_names_returns_single_modifier() {\n    let names = usb_hid::modifier_names(usb_hid::MOD_LEFT_GUI);\n    assert_eq!(names.len(), 1);\n    assert!(names[0].to_lowercase().contains(\"cmd\") || \n            names[0].to_lowercase().contains(\"gui\"));\n}\n\n#[test]\nfn modifier_names_returns_multiple_modifiers() {\n    let mods = usb_hid::MOD_LEFT_CTRL | usb_hid::MOD_LEFT_SHIFT;\n    let names = usb_hid::modifier_names(mods);\n    assert_eq!(names.len(), 2);\n}\n\n#[test]\nfn modifier_names_handles_all_four_modifiers() {\n    let mods = usb_hid::MOD_LEFT_CTRL | usb_hid::MOD_LEFT_SHIFT | \n               usb_hid::MOD_LEFT_ALT | usb_hid::MOD_LEFT_GUI;\n    let names = usb_hid::modifier_names(mods);\n    assert_eq!(names.len(), 4);\n}\n```\n\n## Location\n\nAdd to `src/main.rs` in the `#[cfg(test)] mod tests` section.\n\n## Notes\n\nThese functions are used by the monitor command to display key presses in human-readable form.\n\n## Acceptance Criteria\n\n- [ ] All key codes have human-readable names\n- [ ] Modifier combinations work correctly\n- [ ] Unknown codes handled gracefully","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:18:25.263551-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:18:25.263551-05:00"}
{"id":"savant_elite_rust-bws","title":"BEAD-304: Add TESTING.md","description":"# What / why\n\nWe want a single top-level doc that answers “how do I validate changes?” without searching the repo.\n\n`TESTING.md` is that entrypoint:\n- how to run automated tests\n- what manual scripts exist\n- what prerequisites/caveats apply\n\nThis reduces regressions and makes future changes safer.\n\n# Scope\n\nAdd `TESTING.md` documenting:\n- `cargo test` (unit + integration)\n- manual scripts:\n  - `tests/e2e_hardware_sim.sh`\n  - `tests/e2e_config.sh`\n- where logs go (`tests/logs/`)\n- macOS requirements (Input Monitoring permission, possible `sudo` for USB)\n\n# Acceptance criteria\n\n- `TESTING.md` exists and is accurate.\n- New contributors (or future self) can validate changes quickly.\n\n","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T20:44:46.535866-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:52:26.381001-05:00","closed_at":"2026-01-25T20:55:37.152181-05:00","close_reason":"Added top-level TESTING.md documenting how to run unit/integration tests and the manual E2E scripts.","labels":["docs","phase5","test"],"dependencies":[{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.174349-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-qvt","type":"blocks","created_at":"2026-01-25T23:54:03.609414-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-wyy","type":"blocks","created_at":"2026-01-25T23:54:03.656168-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-51c","type":"blocks","created_at":"2026-01-25T23:54:03.709091-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-yyo","type":"blocks","created_at":"2026-01-25T23:54:03.751149-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-9dr","type":"blocks","created_at":"2026-01-25T23:54:03.791176-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-bws","depends_on_id":"savant_elite_rust-3cr","type":"blocks","created_at":"2026-01-25T23:54:03.835216-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-c4q","title":"Integration tests for 'savant keys' command","description":"# What / Why\n\nThe `savant keys` command needs automated testing to ensure:\n- Command works and produces output\n- All listed keys are actually valid\n- JSON output is parseable\n\n# Scope\n\n## Test cases\n\n1. **Command succeeds**\n   - `savant keys` exits 0\n\n2. **Output contains expected sections**\n   - Contains \"MODIFIERS\"\n   - Contains \"LETTERS\"\n   - Contains \"FUNCTION KEYS\"\n\n3. **JSON output valid**\n   - `savant keys --json` exits 0\n   - Output is valid JSON\n   - JSON contains expected fields\n\n4. **All listed keys are valid**\n   - Parse output, extract key names\n   - Verify each can be used in `savant program --dry-run`\n\n## Implementation\n\n```rust\n#[test]\nfn cli_keys_succeeds() {\n    let output = savant_cmd()\n        .arg(\"keys\")\n        .output()\n        .expect(\"failed to run\");\n    assert!(output.status.success());\n}\n\n#[test]\nfn cli_keys_shows_modifiers() {\n    let output = savant_cmd()\n        .arg(\"keys\")\n        .output()\n        .expect(\"failed to run\");\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    assert!(stdout.contains(\"cmd\") || stdout.contains(\"MODIFIERS\"));\n}\n\n#[test]\nfn cli_keys_json_valid() {\n    let output = savant_cmd()\n        .args([\"keys\", \"--json\"])\n        .output()\n        .expect(\"failed to run\");\n    assert!(output.status.success());\n    let json: serde_json::Value = \n        serde_json::from_slice(\u0026output.stdout).expect(\"invalid JSON\");\n    assert!(json.get(\"modifiers\").is_some());\n}\n```\n\n# Acceptance Criteria\n\n- [ ] Tests verify command basic functionality\n- [ ] Tests verify output format\n- [ ] Tests verify JSON output\n- [ ] CI runs these tests\n\n# Dependencies\n\n- Validates: keys command feature","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T13:22:04.441433-05:00","created_by":"jemanuel","updated_at":"2026-01-26T20:23:54.635882-05:00","closed_at":"2026-01-26T20:23:54.635882-05:00","close_reason":"Tests implemented as part of d8p: cli_keys_shows_modifiers, cli_keys_shows_all_categories, cli_keys_json_is_valid, cli_keys_help. All 4 tests pass.","dependencies":[{"issue_id":"savant_elite_rust-c4q","depends_on_id":"savant_elite_rust-d8p","type":"blocks","created_at":"2026-01-26T13:22:09.243571-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-cbv","title":"Installer: accept SAVANT_VERSION with leading v","description":"install.sh built /releases/download/vvX when users pass SAVANT_VERSION=vX; normalize by stripping a leading 'v'.","status":"closed","priority":3,"issue_type":"bug","created_at":"2026-01-26T02:29:53.340938-05:00","created_by":"jemanuel","updated_at":"2026-01-26T02:30:01.011337-05:00","closed_at":"2026-01-26T02:30:01.011337-05:00","close_reason":"Stripped optional leading 'v' from SAVANT_VERSION before constructing download URLs."}
{"id":"savant_elite_rust-cc5","title":"Unit tests for find_preset function","description":"# Unit tests for find_preset\n\n## What\n\nAdd unit tests for the `find_preset()` function which looks up built-in presets by name.\n\n## Current Coverage\n\nNo unit tests. Only tested via CLI integration tests.\n\n## Test Cases to Add\n\n```rust\n#[test]\nfn find_preset_returns_copy_paste() {\n    let preset = find_preset(\"copy-paste\").unwrap();\n    assert_eq!(preset.name, \"copy-paste\");\n    assert_eq!(preset.left, \"cmd+c\");\n    assert_eq!(preset.middle, \"cmd+a\");\n    assert_eq!(preset.right, \"cmd+v\");\n}\n\n#[test]\nfn find_preset_returns_undo_redo() {\n    let preset = find_preset(\"undo-redo\").unwrap();\n    assert_eq!(preset.name, \"undo-redo\");\n}\n\n#[test]\nfn find_preset_returns_browser() {\n    let preset = find_preset(\"browser\").unwrap();\n    assert_eq!(preset.name, \"browser\");\n}\n\n#[test]\nfn find_preset_returns_zoom() {\n    let preset = find_preset(\"zoom\").unwrap();\n    assert_eq!(preset.name, \"zoom\");\n}\n\n#[test]\nfn find_preset_is_case_insensitive() {\n    assert!(find_preset(\"COPY-PASTE\").is_some());\n    assert!(find_preset(\"Copy-Paste\").is_some());\n    assert!(find_preset(\"cOpY-pAsTe\").is_some());\n}\n\n#[test]\nfn find_preset_returns_none_for_unknown() {\n    assert!(find_preset(\"nonexistent\").is_none());\n    assert!(find_preset(\"\").is_none());\n    assert!(find_preset(\"copy paste\").is_none()); // space instead of hyphen\n}\n\n#[test]\nfn find_preset_all_presets_have_valid_key_actions() {\n    for preset in PRESETS {\n        // Each preset's key actions should parse successfully\n        assert!(KeyAction::from_string(preset.left).is_ok(), \n            \"Preset {} has invalid left: {}\", preset.name, preset.left);\n        assert!(KeyAction::from_string(preset.middle).is_ok(),\n            \"Preset {} has invalid middle: {}\", preset.name, preset.middle);\n        assert!(KeyAction::from_string(preset.right).is_ok(),\n            \"Preset {} has invalid right: {}\", preset.name, preset.right);\n    }\n}\n```\n\n## Location\n\nAdd to `src/main.rs` in the `#[cfg(test)] mod tests` section.\n\n## Acceptance Criteria\n\n- [ ] All preset lookups tested\n- [ ] Case insensitivity verified\n- [ ] Invalid/unknown names return None\n- [ ] All preset key actions are validated as parseable","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:17:50.784215-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:17:50.784215-05:00"}
{"id":"savant_elite_rust-cj2","title":"BEAD-021: Add read-back verification after programming","description":"# What / why\n\nUSB control-transfer success only tells us “the device accepted the packet,” not “the device actually stored the intended mapping.”\n\nGiven that Savant Elite units can have firmware variations and we already support multiple SET_REPORT formats, it’s valuable to add a **best-effort read-back verification** step after programming each pedal.\n\nThis helps users trust the tool:\n- if the device supports read-back, we can confirm that the (modifier, keycode) we wrote matches what the device reports\n- if it doesn’t support read-back, programming still works (we just can’t verify automatically)\n\n# Scope\n\n- After a successful `CMD_SET_KEY_MACRO` send, attempt to read back the pedal mapping via `CMD_GET_KEY_MACRO` (0xCD).\n- Compare the read-back modifier byte + keycode to what we attempted to write.\n- If mismatch is detected, warn the user to verify manually.\n- If the device does not support GET_KEY_MACRO (or response format is unknown), silently skip verification (no hard failure).\n\nOut of scope:\n- making programming fail if verification is unsupported\n- implementing full EEPROM readback or macro sequences\n\n# Design / approach\n\nImplementation strategy (robust across firmware quirks):\n\n1. Implement a helper:\n   - `verify_pedal_programming(handle, interface, pedal_idx, expected_mod, expected_key) -\u003e Result\u003cbool\u003e`\n2. Perform HID `GET_REPORT` control transfers using multiple `wValue` patterns:\n   - feature report, report-id = 0\n   - feature report, report-id = CMD\n   - input report variants\n3. Parse likely response layouts:\n   - `[CMD, pedal, mod, key, ...]`\n   - `[0, CMD, pedal, mod, key, ...]`\n   - `[pedal, mod, key, ...]`\n4. Return:\n   - `Ok(true)` if exact match\n   - `Ok(false)` if definite mismatch\n   - `Err(_)` if unsupported / no parseable response\n\nUX behavior:\n- On `Ok(true)`: print a small “Verified” line (quiet success).\n- On `Ok(false)`: print a warning indicating mismatch and that manual verification is needed.\n- On `Err(_)`: do nothing; this keeps output clean for devices that don’t support readback.\n\n# Testing\n\nAutomated tests are not included because:\n- this depends on device firmware supporting GET_REPORT/GET_KEY_MACRO\n- mocking `rusb::DeviceHandle` is non-trivial and would add brittle test infrastructure\n\nManual validation:\n- Use `tests/e2e_hardware_sim.sh` (BEAD-202) and observe that after programming, the tool may print “Verified” lines (firmware dependent).\n\n# Acceptance criteria\n\n- After successfully programming a pedal, the tool attempts read-back verification.\n- If verification succeeds, output includes a quiet success indicator.\n- If verification returns a mismatch, output includes a warning.\n- If verification is unsupported, programming continues with no extra noise.\n\n# Related beads\n\n- Builds on: BEAD-020 (programming safety; we already handle disconnects)\n\n","status":"closed","priority":2,"issue_type":"feature","assignee":"claude-opus","estimated_minutes":120,"created_at":"2026-01-25T18:53:04.148903-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:01.658816-05:00","closed_at":"2026-01-25T19:33:21.887199-05:00","close_reason":"Implemented verify_pedal_programming() using GET_KEY_MACRO (0xCD) with multiple format attempts. Best-effort verification that gracefully handles unsupported firmware.","labels":["hardening","phase2"],"dependencies":[{"issue_id":"savant_elite_rust-cj2","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.91223-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-cj2","depends_on_id":"savant_elite_rust-7h5","type":"blocks","created_at":"2026-01-25T23:54:03.150759-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-cj2","depends_on_id":"savant_elite_rust-kdb","type":"relates-to","created_at":"2026-01-25T23:54:03.923948-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-d8p","title":"Add 'savant keys' command to list valid key names","description":"# What / Why\n\nUsers constantly ask: \"What key names can I use with savant?\"\n\nCurrently, the only way to find valid key names is to:\n1. Read the source code (`usb_hid::parse_key_name`)\n2. Guess and check with error messages\n3. Search the README (incomplete)\n\nThis is a significant usability gap. A `savant keys` command that lists all valid key names solves this instantly.\n\n# Background\n\nThe valid key data already exists in the codebase:\n- `parse_key_name()` has a match statement with all valid keys\n- `parse_modifier()` has all valid modifier names/aliases\n- HID keycode constants define the complete set\n\nWe just need to expose this existing data through a user-friendly command.\n\n# Scope\n\n## Deliverables\n\n1. **`savant keys` subcommand** - Lists all valid key names\n2. **Categorized output** - Group by type (letters, numbers, function keys, modifiers, special)\n3. **Alias display** - Show aliases (e.g., `cmd` = `command` = `gui` = `meta` = `super`)\n4. **Grep-friendly output** - Simple format that works with `savant keys | grep f12`\n5. **JSON output option** - `savant keys --json` for scripting\n\n## Categories to display\n\n**Modifiers:**\n- `cmd` / `command` / `gui` / `meta` / `super` (all equivalent)\n- `ctrl` / `control`\n- `alt` / `option` / `opt`\n- `shift`\n\n**Letters:** a-z (case insensitive)\n\n**Numbers:** 0-9\n\n**Function keys:** f1-f12\n\n**Special keys:**\n- `enter` / `return`\n- `esc` / `escape`\n- `tab`\n- `space`\n- `backspace` / `delete`\n- `up` / `down` / `left` / `right`\n- etc.\n\n**Punctuation:**\n- `minus` / `-`\n- `equal` / `=`\n- `leftbracket` / `[`\n- `rightbracket` / `]`\n- etc.\n\n# Design\n\n## Output format (default)\n\n```\nMODIFIERS (combine with + before key):\n  cmd, command, gui, meta, super  →  ⌘ Command/GUI\n  ctrl, control                   →  ⌃ Control\n  alt, option, opt                →  ⌥ Option/Alt\n  shift                           →  ⇧ Shift\n\nLETTERS:\n  a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nNUMBERS:\n  0 1 2 3 4 5 6 7 8 9\n\nFUNCTION KEYS:\n  f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12\n\nSPECIAL KEYS:\n  enter, return     tab          space        backspace, delete\n  esc, escape       capslock     printscreen  scrolllock\n  pause             insert       home         end\n  pageup            pagedown\n\nARROW KEYS:\n  up  down  left  right\n\nPUNCTUATION:\n  minus, -          equal, =        leftbracket, [   rightbracket, ]\n  backslash, \\      semicolon, ;    quote, '         grave, `\n  comma, ,          period, .       slash, /\n\nEXAMPLES:\n  savant program --left cmd+c --middle cmd+a --right cmd+v\n  savant program --left ctrl+shift+f1 --middle f5 --right enter\n```\n\n## JSON output format\n\n```json\n{\n  \"modifiers\": [\n    {\"names\": [\"cmd\", \"command\", \"gui\", \"meta\", \"super\"], \"description\": \"Command/GUI\"},\n    {\"names\": [\"ctrl\", \"control\"], \"description\": \"Control\"},\n    ...\n  ],\n  \"keys\": {\n    \"letters\": [\"a\", \"b\", \"c\", ...],\n    \"numbers\": [\"0\", \"1\", \"2\", ...],\n    \"function\": [\"f1\", \"f2\", ...],\n    ...\n  }\n}\n```\n\n## Implementation approach\n\n1. Create static data structures for key categories (or derive from existing match)\n2. Add `Keys` subcommand with optional `--json` flag\n3. Format and print appropriately\n\n# Testing\n\n## Automated\n\n- Integration test: `savant keys` exits successfully with non-empty output\n- Integration test: `savant keys --json` produces valid JSON\n- Unit test: all keys listed are actually parseable by `parse_key_name`\n- Unit test: all modifiers listed are actually parseable by `parse_modifier`\n\n## Manual\n\n- Verify output is readable and complete\n- Verify `savant keys | grep -i shift` works\n\n# Acceptance Criteria\n\n- [ ] `savant keys` lists all valid key names and modifiers\n- [ ] Output is categorized and readable\n- [ ] Aliases are shown (cmd = command = gui = ...)\n- [ ] `savant keys --json` produces valid JSON\n- [ ] All listed keys are actually valid for `savant program`\n- [ ] Examples are included in output\n- [ ] `savant keys --help` explains the command\n\n# Dependencies\n\nNone - this is independent of other features.\n\n# Why This Matters\n\nThis directly addresses the #1 usability question: \"What can I type?\"\n\nInstead of:\n```\n$ savant program --left super+c\nError: Unknown modifier: \"super\"\n```\n\nUsers can:\n```\n$ savant keys | grep -i super\n  cmd, command, gui, meta, super  →  ⌘ Command/GUI\n$ savant program --left cmd+c\n✓ Success\n```\n\n# Estimated Effort\n\nSmall: The data already exists. Main work is formatting output nicely.","status":"closed","priority":1,"issue_type":"feature","assignee":"GrayForge","created_at":"2026-01-26T13:16:52.917437-05:00","created_by":"jemanuel","updated_at":"2026-01-26T20:22:56.982914-05:00","closed_at":"2026-01-26T20:22:56.982914-05:00","close_reason":"Implemented savant keys command with human-readable and JSON output. All 84 tests pass.","dependencies":[{"issue_id":"savant_elite_rust-d8p","depends_on_id":"savant_elite_rust-gge","type":"blocks","created_at":"2026-01-26T13:16:57.208516-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-d8p","depends_on_id":"savant_elite_rust-gge","type":"relates-to","created_at":"2026-01-26T13:16:57.208516-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-dwv","title":"Integration tests for JSON output mode","description":"# What / Why\n\nJSON output mode needs automated testing to ensure:\n- JSON is valid and parseable\n- JSON contains expected fields\n- JSON has no ANSI escape codes\n\n# Scope\n\n## Test cases\n\n1. **Info JSON valid**\n   - `savant info --json` produces valid JSON\n   - Contains device and config fields\n\n2. **Status JSON valid**\n   - `savant status --json` produces valid JSON\n   - Contains device field\n\n3. **No ANSI codes**\n   - JSON output contains no escape sequences (\\\\x1b)\n\n4. **Keys JSON valid** (if feature exists)\n   - `savant keys --json` produces valid JSON\n\n## Implementation\n\n```rust\n#[test]\nfn cli_info_json_valid() {\n    let output = savant_cmd()\n        .args([\"info\", \"--json\"])\n        .output()\n        .expect(\"failed to run\");\n    // May exit non-zero if no device, but should still output JSON\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let json: serde_json::Value = \n        serde_json::from_str(\u0026stdout).expect(\"invalid JSON\");\n    assert!(json.get(\"device\").is_some());\n}\n\n#[test]\nfn cli_json_no_ansi() {\n    let output = savant_cmd()\n        .args([\"info\", \"--json\"])\n        .output()\n        .expect(\"failed to run\");\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    assert!(!stdout.contains(\"\\\\x1b\"));\n    assert!(!stdout.contains(\"\\\\033\"));\n}\n```\n\n# Acceptance Criteria\n\n- [ ] Tests verify JSON validity\n- [ ] Tests verify expected fields present\n- [ ] Tests verify no ANSI escape codes\n- [ ] CI runs these tests\n\n# Dependencies\n\n- Validates: JSON output mode feature","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T13:22:35.809834-05:00","created_by":"jemanuel","updated_at":"2026-01-26T22:29:58.099907-05:00","closed_at":"2026-01-26T22:29:58.099907-05:00","close_reason":"Implemented --json flag for info and status commands with 5 integration tests","dependencies":[{"issue_id":"savant_elite_rust-dwv","depends_on_id":"savant_elite_rust-prn","type":"blocks","created_at":"2026-01-26T13:22:39.704978-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-dz9","title":"Add preset configurations for common use cases","description":"# What / Why\n\nNew users face decision paralysis: \"What should I configure my pedals to do?\"\n\nPre-built presets remove this friction. A user can run:\n```bash\nsavant preset copy-paste\n```\nAnd immediately have a working, useful configuration (cmd+c, cmd+a, cmd+v).\n\nThis is the \"just make it work\" feature for people who want instant value.\n\n# Background\n\nThe most common use cases for foot pedals are well-known:\n- **Copy/paste editing**: cmd+c, cmd+a, cmd+v\n- **Undo/redo**: cmd+z, shift+cmd+z, cmd+y\n- **Browser navigation**: cmd+[, cmd+t, cmd+]\n- **Media control**: Would require media keys (future consideration)\n- **Gaming**: Often game-specific, harder to preset\n\nPresets codify this tribal knowledge.\n\n# Scope\n\n## Deliverables\n\n1. **`savant preset` subcommand** - Apply or list presets\n2. **Built-in presets** - At least 3 useful presets\n3. **`--list` flag** - Show available presets with descriptions\n4. **`--dry-run` flag** - Preview what would be programmed\n5. **Documentation** - README section on presets\n\n## Built-in presets\n\n### `copy-paste` (Primary preset)\nThe most universally useful configuration:\n- Left: `cmd+c` (copy)\n- Middle: `cmd+a` (select all)\n- Right: `cmd+v` (paste)\n\nRationale: Covers 80% of use cases. Select all in middle for \"select all → copy\" or \"paste → select all\" workflows.\n\n### `undo-redo`\nFor editing workflows:\n- Left: `cmd+z` (undo)\n- Middle: `cmd+a` (select all)\n- Right: `shift+cmd+z` (redo)\n\nAlternative: could use `cmd+y` for redo on right, but shift+cmd+z is more universal.\n\n### `browser`\nFor web browsing:\n- Left: `cmd+[` (back)\n- Middle: `cmd+t` (new tab)\n- Right: `cmd+]` (forward)\n\n### `zoom` (Video calls)\n- Left: `cmd+shift+a` (toggle mute)\n- Middle: `cmd+shift+v` (toggle video)\n- Right: `cmd+w` (leave meeting)\n\nNote: Zoom shortcuts may vary; this is for macOS Zoom.\n\n## User-defined presets (stretch goal)\n\nAllow users to define presets in `~/.config/savant-elite/presets/`:\n```\n# ~/.config/savant-elite/presets/gaming.conf\nleft=space\nmiddle=ctrl+r\nright=shift\n```\n\nThen: `savant preset gaming`\n\n# Design\n\n## CLI interface\n\n```bash\n# List available presets\nsavant preset --list\nsavant preset -l\n\n# Apply a preset\nsavant preset copy-paste\n\n# Preview without programming\nsavant preset copy-paste --dry-run\n\n# Show what a preset contains\nsavant preset copy-paste --show\n```\n\n## Output format (--list)\n\n```\nAVAILABLE PRESETS:\n\n  copy-paste    Copy/Select/Paste workflow (cmd+c, cmd+a, cmd+v)\n  undo-redo     Undo/Select/Redo workflow (cmd+z, cmd+a, shift+cmd+z)\n  browser       Browser navigation (cmd+[, cmd+t, cmd+])\n  zoom          Zoom video calls (mute, video, leave)\n\nUse: savant preset \u003cname\u003e [--dry-run]\n```\n\n## Output format (--show)\n\n```\nPRESET: copy-paste\n  Copy/Select/Paste workflow\n\n  Left:   cmd+c  (Copy)\n  Middle: cmd+a  (Select All)\n  Right:  cmd+v  (Paste)\n\nTo apply: savant preset copy-paste\n```\n\n## Implementation approach\n\n1. Define preset data structure:\n   ```rust\n   struct Preset {\n       name: \u0026'static str,\n       description: \u0026'static str,\n       left: \u0026'static str,\n       middle: \u0026'static str,\n       right: \u0026'static str,\n   }\n   ```\n\n2. Static array of built-in presets\n\n3. `preset` subcommand that:\n   - With `--list`: prints all presets\n   - With `--show \u003cname\u003e`: prints preset details\n   - With `\u003cname\u003e`: calls the existing `program` logic with preset values\n   - With `--dry-run`: passes through to program's dry-run\n\n# Testing\n\n## Automated\n\n- Integration test: `savant preset --list` shows all presets\n- Integration test: `savant preset copy-paste --dry-run` succeeds\n- Integration test: `savant preset invalid-name` fails gracefully\n- Unit test: all preset key combinations are valid\n\n## Manual\n\n- Apply preset on real hardware, verify it works\n- Test with `--dry-run` to see configuration\n\n# Acceptance Criteria\n\n- [ ] `savant preset --list` shows all available presets\n- [ ] `savant preset copy-paste` programs the pedals (or `--dry-run`)\n- [ ] `savant preset \u003cname\u003e --show` displays preset details\n- [ ] At least 3 built-in presets: copy-paste, undo-redo, browser\n- [ ] Invalid preset name gives helpful error\n- [ ] README documents the preset feature\n\n# Dependencies\n\nThis should work independently, but could benefit from:\n- `savant keys` for users who want to understand what's being programmed\n\n# Considerations\n\n## Why not just document the commands?\n\nDocumentation requires users to copy/paste. Presets are:\n- One command\n- Memorable names\n- Self-documenting via `--list` and `--show`\n\n## Why these specific presets?\n\nBased on common foot pedal use cases from:\n- Kinesis forums\n- Ergonomic keyboard communities\n- Personal experience with repetitive strain\n\n## Future: user-defined presets\n\nIf user-defined presets are added later:\n- Store in `~/.config/savant-elite/presets/`\n- Same format as main config file\n- `--list` shows both built-in and user presets\n\n# Estimated Effort\n\nSmall-medium: Mostly data definition and CLI glue. Reuses existing program logic.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-26T13:17:27.451358-05:00","created_by":"jemanuel","updated_at":"2026-01-27T01:51:23.580203-05:00","closed_at":"2026-01-27T01:51:23.580203-05:00","close_reason":"Implemented preset command with 4 built-in presets (copy-paste, undo-redo, browser, zoom). Features: --list, --show, --dry-run. Added 8 integration tests."}
{"id":"savant_elite_rust-ewe","title":"Add config profiles (save/load named configurations)","description":"# What / Why\n\nUsers often need different pedal configurations for different contexts:\n- **Work**: Copy/paste shortcuts\n- **Gaming**: Game-specific keys\n- **Music production**: DAW shortcuts\n- **Video editing**: Timeline navigation\n\nCurrently, switching configs requires re-running `savant program` with different arguments, or manually editing config files.\n\nConfig profiles let users save and switch between named configurations instantly.\n\n# Background\n\nThe existing config system:\n- Single config file: `~/.config/savant-elite/pedals.conf`\n- Format: `left=X\\nmiddle=Y\\nright=Z`\n- Loaded by `savant info` for display\n- Written by `savant program` after successful programming\n\nProfiles extend this with:\n- Named config files: `~/.config/savant-elite/profiles/\u003cname\u003e.conf`\n- Commands to save/load/list profiles\n- Optional: set a profile as default\n\n# Scope\n\n## Deliverables\n\n1. **`savant config save \u003cname\u003e`** - Save current config as named profile\n2. **`savant config load \u003cname\u003e`** - Load and apply a profile\n3. **`savant config list`** - List all saved profiles\n4. **`savant config show \u003cname\u003e`** - Display profile contents\n5. **`savant config delete \u003cname\u003e`** - Delete a profile\n6. **Profile storage** - Profiles stored in `~/.config/savant-elite/profiles/`\n\n## CLI interface\n\n```bash\n# Save current config as \"work\"\nsavant config save work\n\n# List all profiles\nsavant config list\n# Output:\n#   work      cmd+c, cmd+a, cmd+v\n#   gaming    space, ctrl+r, shift\n\n# Show a specific profile\nsavant config show work\n# Output:\n#   Profile: work\n#   Left:   cmd+c\n#   Middle: cmd+a\n#   Right:  cmd+v\n\n# Load and apply a profile (programs device)\nsavant config load work\n\n# Load with dry-run\nsavant config load work --dry-run\n\n# Delete a profile\nsavant config delete gaming\n```\n\n## Storage format\n\nProfiles use the same format as the main config:\n```\n# ~/.config/savant-elite/profiles/work.conf\nleft=cmd+c\nmiddle=cmd+a\nright=cmd+v\n```\n\nThis means:\n- Existing parsing code works\n- Users can manually edit profiles\n- Profiles can be shared (just copy the file)\n\n# Design\n\n## Implementation approach\n\n1. Add `config` subcommand with sub-subcommands (save/load/list/show/delete)\n2. Create profiles directory on first save\n3. `save` copies current pedals.conf to profiles/\u003cname\u003e.conf\n4. `load` copies profiles/\u003cname\u003e.conf to pedals.conf AND programs device\n5. `list` reads profiles directory\n6. `show` reads and displays profile\n7. `delete` removes profile file\n\n## Behavior notes\n\n### `config load` programs the device\n\nUnlike just copying files, `config load` should:\n1. Read the profile\n2. Program the device (like `savant program`)\n3. Update pedals.conf\n\nIf the device is in PLAY mode, show the same instructions as `savant program`.\n\nAlternative: `config load` just updates the local file, user runs `savant program` separately. This is simpler but less convenient.\n\n### Profile name validation\n\nNames should be filesystem-safe:\n- Alphanumeric + hyphen + underscore\n- No spaces, no special characters\n- Case-insensitive on macOS (HFS+ default)\n\n### Overwrite protection\n\n`config save \u003cname\u003e` on existing profile should:\n- Warn: \"Profile 'work' exists. Overwrite? [y/N]\"\n- Or require `--force` flag\n\n# Testing\n\n## Automated\n\n- Integration test: `savant config save test-profile` creates file\n- Integration test: `savant config list` shows saved profiles\n- Integration test: `savant config show test-profile` displays content\n- Integration test: `savant config delete test-profile` removes file\n- Integration test: invalid profile name rejected\n- Unit test: profile name validation\n\n## Manual\n\n- Save a profile, load it, verify device is programmed\n- Test overwrite protection\n- Verify profiles survive app updates\n\n# Acceptance Criteria\n\n- [ ] `savant config save \u003cname\u003e` saves current config as profile\n- [ ] `savant config load \u003cname\u003e` loads and programs profile\n- [ ] `savant config list` shows all profiles with summary\n- [ ] `savant config show \u003cname\u003e` displays profile details\n- [ ] `savant config delete \u003cname\u003e` removes profile\n- [ ] Profile names are validated (alphanumeric, hyphen, underscore)\n- [ ] Overwrite protection for existing profiles\n- [ ] Works with `--dry-run` for load\n\n# Dependencies\n\n- Should work with verbose mode (`-v`) for debugging\n- Should work with JSON output (`--json`) for scripting\n\n# Considerations\n\n## Why not just tell users to copy files?\n\n- Discoverability: users don't know where files are\n- Convenience: one command vs find+copy+program\n- Validation: profile format is verified on load\n\n## Profile metadata?\n\nCould store additional info:\n```\n# description: Work shortcuts for copy/paste\n# created: 2024-01-15\nleft=cmd+c\n...\n```\n\nNice to have, not essential for v1.\n\n# Estimated Effort\n\nMedium: New subcommand structure, file operations, but reuses existing parsing/programming logic.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-26T13:19:23.334799-05:00","created_by":"jemanuel","updated_at":"2026-01-27T12:05:06.354893-05:00","closed_at":"2026-01-27T12:05:06.354893-05:00","close_reason":"Implemented config profiles with save/load/list/show/delete commands. Added 12 integration tests."}
{"id":"savant_elite_rust-fjx","title":"BEAD-022: Improve HidApi lifecycle management","description":"# What / why\n\nThe codebase uses `hidapi` for device enumeration and for reading Play-mode input.\n\nBefore this bead, `SavantElite::new()` did a “smoke check” by constructing a `HidApi` instance and immediately dropping it. Then most methods constructed a fresh `HidApi` again.\n\nThis pattern is suboptimal:\n- redundant work on every CLI invocation\n- confusing failure modes (init might fail in `new()` but succeed later, or vice versa)\n- gives a false impression that `SavantElite` maintains a long-lived HID context (it didn’t)\n\n# Scope\n\nPick one clear approach:\n- Either store `HidApi` on `SavantElite`, or\n- Remove the redundant init-check and let each command initialize when needed.\n\n# Design decision\n\nWe chose the minimal/least-risk option:\n- **Remove the init-check in `SavantElite::new()`**.\n\nRationale:\n- `HidApi::new()` is already called by each command that needs it.\n- Keeping HID enumeration local to the command avoids lifetime tangles with `HidDevice` handles.\n- Avoids giving the impression that `SavantElite` holds state that must be kept fresh.\n\n# Testing\n\nNo new tests needed:\n- behavior is unchanged except removing redundant work\n\n# Acceptance criteria\n\n- `SavantElite::new()` no longer initializes `HidApi` as a side-effect.\n- Commands that need HID still initialize it and surface a contextual error if init fails.\n\n","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T20:44:25.465944-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:25.152586-05:00","closed_at":"2026-01-25T20:55:17.533443-05:00","close_reason":"Removed redundant HidApi initialization check in SavantElite::new(); commands now initialize HidApi only when needed.","labels":["cleanup","hardening","phase2"],"dependencies":[{"issue_id":"savant_elite_rust-fjx","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.280776-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-flg","title":"BEAD-105: Interface number validation test coverage","description":"# What / why\n\nBEAD-005 adds clap validation for the `--interface` argument in `raw-cmd`.\n\nBecause the validation happens *inside clap parsing*, the best way to assert it stays correct is an integration test that:\n- invokes the compiled `savant` binary\n- passes invalid arguments\n- verifies clap rejects them\n\nThis bead exists to explicitly connect:\n- BEAD-005 (the validation change)\n- BEAD-201 (the test coverage)\n\n# Scope\n\nNo separate unit tests are added.\n\nInstead, enforce coverage via BEAD-201 integration tests:\n- `cli_raw_cmd_rejects_negative_interface`\n- `cli_raw_cmd_rejects_interface_too_large`\n\n# Acceptance criteria\n\n- Those integration tests exist and pass.\n- They fail if the clap range validation is removed.\n\n","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T23:43:17.51836-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:27.036078-05:00","closed_at":"2026-01-25T23:43:21.664235-05:00","close_reason":"Covered by BEAD-201 integration tests (cli_raw_cmd_rejects_negative_interface + cli_raw_cmd_rejects_interface_too_large); no separate unit test needed for clap-level validation.","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-flg","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.125456-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-flg","depends_on_id":"savant_elite_rust-5iu","type":"validates","created_at":"2026-01-25T23:54:03.10339-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-gge","title":"EPIC: UX Improvements Phase 1 - Core Usability","description":"# Purpose\n\nThis epic tracks the first wave of user experience improvements for savant-elite after the initial hardening phase. These features are specifically chosen to:\n\n1. **Reduce friction** - Make the tool easier to discover and use\n2. **Enable power users** - Support scripting and automation\n3. **Improve troubleshooting** - Give users visibility when things go wrong\n\n# Background\n\nThe project completed a comprehensive hardening phase (BEAD-001 through BEAD-304) covering:\n- Input validation and error handling\n- USB disconnect detection\n- Read-back verification\n- Comprehensive test coverage\n\nWith the foundation solid, we now focus on UX improvements that make the tool more accessible and powerful.\n\n# Scope\n\nThis epic covers 5 high-impact features:\n\n1. **Shell completions** (zsh/bash/fish) - Tab completion for commands and key names\n2. **Key listing** - `savant keys` to show all valid key names and modifiers\n3. **Presets** - Pre-built configurations for common use cases\n4. **JSON output** - Machine-readable output for scripting\n5. **Verbose mode** - Debug output for troubleshooting\n\n# Why these 5?\n\nThese were selected from 30 candidates using criteria:\n- **Accretive**: Adds clear value without complexity\n- **Pragmatic**: Low implementation risk, high user impact\n- **Intuitive**: Makes the tool more discoverable\n- **Standard**: Follows CLI best practices (completions, JSON, verbose)\n\n# Out of Scope (for now)\n\n- Interactive TUI mode (higher complexity)\n- Config profiles (can be done manually with file copy)\n- Remote programming (niche use case)\n\n# Success Criteria\n\n- New users can discover commands via tab completion\n- `savant keys` answers \"what keys can I use?\"\n- Common configs achievable in one command\n- Scripting possible via JSON output\n- Troubleshooting enabled via verbose mode\n\n# Testing Strategy\n\nEach feature includes:\n- Unit tests for new parsing/logic\n- Integration tests for CLI behavior\n- Documentation updates\n\n# Related Work\n\nThis epic builds on the hardening work in the now-closed PLAN bead (savant_elite_rust-1pa).","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-26T13:16:03.221578-05:00","created_by":"jemanuel","updated_at":"2026-01-27T01:52:06.072391-05:00","closed_at":"2026-01-27T01:52:06.072391-05:00","close_reason":"All Phase 1 features complete: shell completions, keys command, presets, JSON output, verbose mode"}
{"id":"savant_elite_rust-gn0","title":"Add configurable timeout for hardware operations","description":"# What / Why\n\nUSB operations have hardcoded timeouts that may not work for all setups:\n- Some USB hubs add latency\n- Some device firmware is slower to respond\n- Network-attached USB (rare) has high latency\n\nWhen timeouts are too short, operations fail mysteriously. When they're too long, failures take forever to surface.\n\nA `--timeout` flag gives users control.\n\n# Background\n\nCurrent hardcoded timeouts in the code:\n- Control transfer timeout: ~1000ms\n- Monitor wait timeout: 60s (already configurable conceptually)\n- Device enumeration: effectively instant\n\nThe most critical is the control transfer timeout used during programming.\n\n# Scope\n\n## Deliverables\n\n1. **`--timeout \u003cms\u003e` flag** - Set timeout for USB operations\n2. **Sensible default** - Current behavior unchanged if not specified\n3. **Applies to programming** - Control transfers use this timeout\n4. **Applies to monitoring** - Device wait loop uses this timeout\n5. **Documentation** - README section on timeout configuration\n\n## CLI interface\n\n```bash\n# Use custom timeout (5 seconds)\nsavant program --left cmd+c --timeout 5000\n\n# Very long timeout for slow USB\nsavant program --left cmd+c --timeout 30000\n\n# Show current default in help\nsavant program --help\n# --timeout \u003cms\u003e  USB operation timeout in milliseconds [default: 1000]\n```\n\n## Where timeout applies\n\n### Control transfers (programming)\n```rust\nhandle.write_control(\n    request_type,\n    request,\n    value,\n    index,\n    \u0026buffer,\n    Duration::from_millis(timeout_ms), // Use user-specified timeout\n)?;\n```\n\n### Device wait loop (auto-monitor)\nThe existing 60s timeout for \"waiting for play mode\" could also be configurable:\n```bash\nsavant program --monitor --timeout 120000  # Wait up to 2 minutes\n```\n\n### Enumeration\nDevice enumeration is typically instant and doesn't need a timeout. But if USB enumeration itself hangs, the whole tool hangs. This is harder to timeout.\n\n# Design\n\n## Implementation approach\n\n1. Add `--timeout` to global CLI options (applies to all commands)\n2. Pass timeout value through to `SavantElite` struct\n3. Use timeout in all `write_control`/`read_control` calls\n4. Use timeout in monitor wait loop\n\n## Default value\n\nKeep current behavior as default:\n- Control transfers: 1000ms\n- Monitor wait: 60000ms\n\nIf user specifies `--timeout`, use it for control transfers. Monitor wait could have a separate flag or use the same value (TBD).\n\n## Validation\n\n- Minimum: 100ms (anything less is probably a mistake)\n- Maximum: 600000ms (10 minutes, beyond this something is very wrong)\n\n```bash\n$ savant program --left a --timeout 50\nError: Timeout must be at least 100ms\n```\n\n# Testing\n\n## Automated\n\n- Integration test: `--timeout` flag accepted\n- Integration test: invalid timeout rejected (too low, too high)\n- Unit test: timeout value parsed correctly\n\n## Manual\n\n- Test with very low timeout, verify operations fail fast\n- Test with high timeout, verify operations wait longer\n- Test on slow USB hub if available\n\n# Acceptance Criteria\n\n- [ ] `--timeout \u003cms\u003e` flag sets USB operation timeout\n- [ ] Default timeout unchanged from current behavior\n- [ ] Timeout validation (100ms minimum, 600000ms maximum)\n- [ ] Timeout applies to control transfers during programming\n- [ ] `--help` shows timeout option with default value\n- [ ] README documents timeout configuration\n\n# Dependencies\n\n- Should work with verbose mode to see actual timeout being used\n\n# Considerations\n\n## Separate timeouts?\n\nCould have:\n- `--usb-timeout` for control transfers\n- `--wait-timeout` for monitor wait loop\n\nSingle `--timeout` is simpler for v1. Can split later if needed.\n\n## Environment variable?\n\n`SAVANT_TIMEOUT=5000` for persistent configuration. Nice to have.\n\n## Why milliseconds?\n\n- Matches what rusb expects\n- Precise control for debugging\n- Consistent with other USB tools\n\nAlternative: seconds with decimal (`--timeout 1.5`). More human-friendly but less precise.\n\n# Estimated Effort\n\nSmall: Single flag, pass through to existing code, minimal new logic.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-26T13:20:29.204561-05:00","created_by":"jemanuel","updated_at":"2026-01-27T12:35:49.437122-05:00","closed_at":"2026-01-27T12:35:49.437122-05:00","close_reason":"Implemented --timeout flag with 100ms-600000ms range, verbose logging, and 8 integration tests"}
{"id":"savant_elite_rust-gs3","title":"Integration tests for verbose/debug mode","description":"# What / Why\n\nVerbose mode needs automated testing to ensure:\n- Flag is accepted by CLI\n- Verbose output goes to stderr (not stdout)\n- Normal output unaffected by verbose flag\n- Verbose output contains expected debugging information\n\n# Scope\n\n## Test cases\n\n1. **Verbose flag accepted**\n   - `savant info -v` exits successfully\n   - `savant info --verbose` exits successfully\n\n2. **Output separation**\n   - Verbose output goes to stderr\n   - Normal output still goes to stdout\n   - `savant info -v 2\u003e/dev/null` produces clean stdout\n\n3. **Verbose content**\n   - Stderr contains `[verbose]` markers\n   - Contains expected debugging info (device enumeration, etc.)\n\n4. **Multiple commands**\n   - `savant status -v` works\n   - `savant program --dry-run -v` shows command details\n\n# Acceptance Criteria\n\n- [ ] Tests verify -v/--verbose flag accepted\n- [ ] Tests verify output goes to correct streams\n- [ ] Tests verify verbose markers present in stderr\n- [ ] CI runs these tests","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T13:38:22.610646-05:00","created_by":"jemanuel","updated_at":"2026-01-26T21:11:48.841514-05:00","closed_at":"2026-01-26T21:11:48.841514-05:00","close_reason":"Tests implemented as part of rav: cli_verbose_flag_accepted, cli_verbose_long_flag_accepted, cli_verbose_output_goes_to_stderr, cli_verbose_shows_mode_enabled, cli_verbose_with_dry_run. All 5 tests pass.","dependencies":[{"issue_id":"savant_elite_rust-gs3","depends_on_id":"savant_elite_rust-rav","type":"blocks","created_at":"2026-01-26T13:45:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-h44","title":"Integration tests for verbose/debug mode","description":"# Test bead\n\nAutomated tests for the feature.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel","updated_at":"2026-01-26T21:11:48.843611-05:00","closed_at":"2026-01-26T21:11:48.843611-05:00","close_reason":"Tests implemented as part of rav: cli_verbose_flag_accepted, cli_verbose_long_flag_accepted, cli_verbose_output_goes_to_stderr, cli_verbose_shows_mode_enabled, cli_verbose_with_dry_run. All 5 tests pass.","dependencies":[{"issue_id":"savant_elite_rust-h44","depends_on_id":"savant_elite_rust-rav","type":"blocks","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-hzj","title":"Integration tests for shell completions","description":"# What / Why\n\nShell completion generation needs automated testing to ensure:\n- Completion scripts are generated for all supported shells\n- Generated scripts are valid (parseable by the shell)\n- Feature doesn't regress with code changes\n\n# Scope\n\n## Test cases\n\n1. **Completion generation succeeds**\n   - `savant completions zsh` exits 0\n   - `savant completions bash` exits 0\n   - `savant completions fish` exits 0\n\n2. **Output is non-empty**\n   - Each shell produces substantial output (\u003e100 bytes)\n\n3. **Invalid shell rejected**\n   - `savant completions invalid` fails gracefully\n\n4. **Help shows option**\n   - `savant completions --help` shows shell choices\n\n## Implementation\n\nAdd to `tests/cli_validation.rs`:\n```rust\n#[test]\nfn cli_completions_zsh() {\n    let output = savant_cmd()\n        .arg(\"completions\")\n        .arg(\"zsh\")\n        .output()\n        .expect(\"failed to run\");\n    assert!(output.status.success());\n    assert!(output.stdout.len() \u003e 100);\n}\n\n#[test]\nfn cli_completions_bash() {\n    // Similar\n}\n\n#[test]\nfn cli_completions_fish() {\n    // Similar\n}\n\n#[test]\nfn cli_completions_invalid_shell() {\n    let output = savant_cmd()\n        .arg(\"completions\")\n        .arg(\"invalid\")\n        .output()\n        .expect(\"failed to run\");\n    assert!(!output.status.success());\n}\n```\n\n# Acceptance Criteria\n\n- [ ] Tests pass for all supported shells\n- [ ] Tests detect if completion generation breaks\n- [ ] CI runs these tests\n\n# Dependencies\n\n- Validates: shell completions feature","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T13:21:49.397647-05:00","created_by":"jemanuel","updated_at":"2026-01-26T20:26:39.059506-05:00","closed_at":"2026-01-26T20:26:39.059506-05:00","close_reason":"Tests implemented as part of 4ie: cli_completions_zsh, cli_completions_bash, cli_completions_fish, cli_completions_help, cli_completions_rejects_invalid_shell. All 5 tests pass.","dependencies":[{"issue_id":"savant_elite_rust-hzj","depends_on_id":"savant_elite_rust-4ie","type":"blocks","created_at":"2026-01-26T13:21:53.991478-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-i35","title":"BEAD-006: Config not saved on partial programming success","description":"# What / why\n\n`savant program` has two “sources of truth”:\n- the **device EEPROM** (persistent hardware configuration)\n- a **local config file** (for UI display + user intent + quick retry)\n\nThe local config file is important because:\n- the device EEPROM is effectively write-only (no reliable readback in all firmware)\n- users want `savant info` to show what they last programmed\n- if something fails at the end of the sequence, the tool can still remember what the user was trying to do\n\nBefore this bead, if pedal programming succeeded but the final EEPROM save step failed, we did **not** write the config file. That loses user intent and makes retries harder.\n\nExample failure modes:\n- EEPROM save control transfer fails due to a transient USB hiccup\n- permission/driver issues during final stage\n\nIn these cases, the user often *still wants the config persisted*, even if we warn that it might not have been saved to EEPROM.\n\n# Scope\n\n- Always write the attempted config to disk **after** we’ve finished the programming sequence, even if:\n  - one or more pedals failed, and/or\n  - EEPROM save may have failed\n\n- Do **not** write a config on “hard abort” situations where we explicitly tell the user the device disconnected mid-run and changes were lost in RAM.\n\n# Design / approach\n\n- Construct a `PedalConfig { left, middle, right }` from the requested actions.\n- Call `config.save()` unconditionally at the end of the programming path.\n- If saving the config file fails, print a *non-fatal* note.\n\nThis preserves intent without pretending the device is guaranteed to be programmed.\n\nUX detail:\n- If EEPROM save fails, print a warning like “changes might not persist after unplug”.\n- Still show the pedal visualization so the user can verify what was attempted.\n\n# Testing\n\nAutomated coverage:\n- BEAD-106 covers `PedalConfig` persistence mechanics (serialize/save/load/whitespace parsing).\n\nManual validation (hardware):\n- Use BEAD-202 to run `savant program` and confirm that after a programming attempt, `savant info` reflects the saved config.\n- If you can force an EEPROM-save failure (hard, device/OS dependent), verify:\n  - the tool warns about persistence\n  - the config file still updates to the attempted mapping\n\n# Acceptance criteria\n\n- After any completed programming attempt (even with warnings), the local config file is updated to the requested mapping.\n- `savant info` uses this file to render the pedal visualization.\n- If config save fails, the CLI prints a non-fatal note; programming result reporting remains intact.\n\n# Related beads\n\n- Validated by: BEAD-106 (persistence tests), BEAD-202 (manual hardware flow)\n\n","status":"closed","priority":2,"issue_type":"bug","assignee":"claude-opus","estimated_minutes":30,"created_at":"2026-01-25T18:52:37.265637-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:48:02.107793-05:00","closed_at":"2026-01-25T18:57:29.287111-05:00","close_reason":"Fixed: Config now saved regardless of programming success for user intent preservation","labels":["data-loss","medium","phase1"],"dependencies":[{"issue_id":"savant_elite_rust-i35","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.019392-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-ip9","title":"Fix deprecated assert_cmd::Command::cargo_bin usage","description":"# What / why\n\n`assert_cmd::Command::cargo_bin(\"savant\")` can emit a deprecation warning depending on assert_cmd version.\n\nCI should be warning-clean so that:\n- real regressions stand out\n- contributors don’t habituate to ignoring CI output\n\n# Scope\n\n- Remove usage of deprecated `Command::cargo_bin` API in integration tests.\n- Prefer the stable approach provided by cargo during tests:\n  - `env!(\"CARGO_BIN_EXE_savant\")`\n\n# Acceptance criteria\n\n- `cargo test` runs without the deprecation warning.\n- Integration tests continue to work on CI.\n\n","status":"closed","priority":3,"issue_type":"task","estimated_minutes":15,"created_at":"2026-01-25T19:44:34.058988-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:52:33.634406-05:00","closed_at":"2026-01-25T20:07:50.028258-05:00","close_reason":"No longer applicable (already fixed)","labels":["infra","test"],"dependencies":[{"issue_id":"savant_elite_rust-ip9","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:42.329296-05:00","created_by":"jemanuel"}],"comments":[{"id":1,"issue_id":"savant_elite_rust-ip9","author":"jemanuel","text":"Reviewed current tree: no  usage remains (tests use ). Closing as already resolved.","created_at":"2026-01-26T01:07:35Z"},{"id":2,"issue_id":"savant_elite_rust-ip9","author":"jemanuel","text":"Reviewed current tree: no Command::cargo_bin usage remains (tests use env!(\"CARGO_BIN_EXE_savant\")). Closing as already resolved.","created_at":"2026-01-26T01:07:45Z"}]}
{"id":"savant_elite_rust-jom","title":"Test documentation and CI integration guide","description":"# Test documentation and CI integration guide\n\n## What\n\nCreate comprehensive documentation for the test suite, including how to run tests and integrate with CI.\n\n## Deliverable: tests/README.md\n\n```markdown\n# Savant Elite Test Suite\n\n## Quick Start\n\n# Run all unit tests\ncargo test\n\n# Run all tests including integration\ncargo test --all-targets\n\n# Run E2E scripts\n./tests/e2e/run_all.sh\n\n## Test Categories\n\n### Unit Tests (src/main.rs)\nPure function tests that dont require hardware:\n- KeyAction parsing\n- PedalConfig serialization\n- USB HID code helpers\n- Profile validation\n\n### Integration Tests (tests/cli_validation.rs)\nCLI-level tests via process execution:\n- Argument validation\n- Error messages\n- JSON output format\n- Help/version output\n\n### E2E Scripts (tests/e2e/)\nShell scripts with detailed logging:\n- Full workflow tests\n- Config validation\n- Profile management\n- Preset workflows\n\n### Hardware Tests (tests/e2e/test_hardware.sh)\nOptional tests requiring physical device:\n- Skipped automatically if no device\n- Enable with: ENABLE_HARDWARE=1 ./tests/e2e/test_hardware.sh\n\n## Running Specific Tests\n\n# Single unit test\ncargo test parse_key_action_cmd_c\n\n# Tests matching pattern\ncargo test pedal_config\n\n# Integration tests only\ncargo test --test cli_validation\n\n## Environment Variables\n\n- LOG_LEVEL: E2E log verbosity (DEBUG, INFO, WARN, ERROR)\n- LOG_FILE: E2E log output file\n- SAVANT: Path to savant binary (default: searches PATH)\n- ENABLE_HARDWARE: Enable hardware tests (default: 0)\n\n## CI Integration\n\nGitHub Actions workflow example included at .github/workflows/test.yml\n```\n\n## Acceptance Criteria\n\n- [ ] README covers all test types\n- [ ] Running instructions clear\n- [ ] Environment variables documented\n- [ ] CI example provided","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:22:04.247237-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:22:04.247237-05:00","dependencies":[{"issue_id":"savant_elite_rust-jom","depends_on_id":"savant_elite_rust-kjd","type":"blocks","created_at":"2026-01-27T15:23:37.056422-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-jom","depends_on_id":"savant_elite_rust-cc5","type":"blocks","created_at":"2026-01-27T15:23:37.114479-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-jom","depends_on_id":"savant_elite_rust-7gp","type":"blocks","created_at":"2026-01-27T15:23:37.18062-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-jom","depends_on_id":"savant_elite_rust-br3","type":"blocks","created_at":"2026-01-27T15:23:37.246598-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-jom","depends_on_id":"savant_elite_rust-6g1","type":"blocks","created_at":"2026-01-27T15:23:37.303886-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-jom","depends_on_id":"savant_elite_rust-899","type":"blocks","created_at":"2026-01-27T15:23:37.362031-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-jom","depends_on_id":"savant_elite_rust-ycp","type":"blocks","created_at":"2026-01-27T15:23:37.430807-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-jom","depends_on_id":"savant_elite_rust-l87","type":"blocks","created_at":"2026-01-27T15:23:37.485351-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-jom","depends_on_id":"savant_elite_rust-86q","type":"blocks","created_at":"2026-01-27T15:23:37.548637-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-jom","depends_on_id":"savant_elite_rust-4vu","type":"blocks","created_at":"2026-01-27T15:23:37.610173-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-k4e","title":"EPIC: Comprehensive Test Coverage","description":"# EPIC: Comprehensive Test Coverage\n\n## Overview\n\nThis epic covers achieving comprehensive test coverage for savant-elite without relying on mocks or fake implementations. The strategy is:\n\n1. **Unit Tests** - Test all pure functions that don't require hardware\n2. **CLI Integration Tests** - Test all CLI commands via process execution\n3. **E2E Test Scripts** - Shell scripts with detailed logging for manual/CI testing\n4. **Hardware Test Suite** - Optional tests that run when device is connected\n\n## Current State\n\n- 47 unit tests in src/main.rs (KeyAction, PedalConfig, usb_hid parsing)\n- 93 integration tests in tests/cli_validation.rs (CLI argument validation)\n- No E2E workflow scripts with logging\n- No hardware test documentation\n\n## Goals\n\n1. 100% coverage of pure functions (no mocks needed)\n2. Complete CLI command coverage (all subcommands, flags, error cases)\n3. E2E scripts for real-world workflows with detailed logging\n4. Hardware test suite for when device is available\n5. Test documentation and CI integration guidance\n\n## Architecture\n\n```\ntests/\n├── cli_validation.rs      # Existing CLI tests\n├── unit_tests.rs          # New: Additional unit tests\n├── workflow_tests.rs      # New: E2E workflow integration tests\n├── e2e/\n│   ├── run_all.sh         # Master E2E script\n│   ├── test_config.sh     # Config workflow tests\n│   ├── test_profiles.sh   # Profile management tests\n│   ├── test_presets.sh    # Preset workflow tests\n│   └── test_hardware.sh   # Hardware tests (when device present)\n└── fixtures/\n    ├── valid_config.conf\n    ├── invalid_configs/\n    └── test_profiles/\n```\n\n## Non-Goals\n\n- No mocking of USB/HID APIs\n- No fake device implementations\n- Tests should work without hardware (except hardware-specific suite)","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-27T15:17:15.109137-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:17:15.109137-05:00","dependencies":[{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-kjd","type":"blocks","created_at":"2026-01-27T15:23:27.14432-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-cc5","type":"blocks","created_at":"2026-01-27T15:23:27.210533-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-7gp","type":"blocks","created_at":"2026-01-27T15:23:27.275659-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-br3","type":"blocks","created_at":"2026-01-27T15:23:27.339522-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-6g1","type":"blocks","created_at":"2026-01-27T15:23:27.399917-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-899","type":"blocks","created_at":"2026-01-27T15:23:28.087265-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-ycp","type":"blocks","created_at":"2026-01-27T15:23:28.154773-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-l87","type":"blocks","created_at":"2026-01-27T15:23:28.220762-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-86q","type":"blocks","created_at":"2026-01-27T15:23:28.289162-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-4vu","type":"blocks","created_at":"2026-01-27T15:23:28.354601-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-9k5","type":"blocks","created_at":"2026-01-27T15:23:28.424502-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-1w8","type":"blocks","created_at":"2026-01-27T15:23:30.045445-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-54y","type":"blocks","created_at":"2026-01-27T15:23:30.10588-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-k4e","depends_on_id":"savant_elite_rust-jom","type":"blocks","created_at":"2026-01-27T15:23:30.171529-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-kdb","title":"BEAD-021 (duplicate): Add read-back verification after programming","description":"# NOTE: duplicate / historical artifact\n\nThis bead is a **duplicate** of the canonical BEAD-021 implementation:\n- Canonical: `savant_elite_rust-cj2` (BEAD-021)\n\nWhy keep this around?\n- It records that BEAD-021 was accidentally created twice during plan → beads conversion.\n- It provides an explicit cross-reference so future triage doesn’t wonder “why are there two BEAD-021s?”\n\n# What to do\n\n- Do not implement work under this bead.\n- If you need the actual spec + rationale + acceptance criteria, use `savant_elite_rust-cj2`.\n\n","status":"closed","priority":2,"issue_type":"feature","estimated_minutes":120,"created_at":"2026-01-25T18:53:12.158387-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:49:12.369701-05:00","closed_at":"2026-01-25T19:37:57.932002-05:00","close_reason":"Duplicate of cj2 - read-back verification already implemented in verify_pedal_programming()","labels":["hardening","phase2"],"dependencies":[{"issue_id":"savant_elite_rust-kdb","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.860675-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-kdb","depends_on_id":"savant_elite_rust-cj2","type":"relates-to","created_at":"2026-01-25T23:54:03.923332-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-kjd","title":"Unit tests for validate_profile_name function","description":"# Unit tests for validate_profile_name\n\n## What\n\nAdd comprehensive unit tests for the `validate_profile_name()` function which validates profile names for the config save/load feature.\n\n## Current Coverage\n\nThis function has NO unit tests. It's only tested indirectly via CLI integration tests.\n\n## Test Cases to Add\n\n```rust\n#[test]\nfn validate_profile_name_accepts_simple_name() {\n    assert!(validate_profile_name(\"myprofile\").is_ok());\n}\n\n#[test]\nfn validate_profile_name_accepts_with_numbers() {\n    assert!(validate_profile_name(\"profile123\").is_ok());\n}\n\n#[test]\nfn validate_profile_name_accepts_with_hyphen() {\n    assert!(validate_profile_name(\"my-profile\").is_ok());\n}\n\n#[test]\nfn validate_profile_name_accepts_with_underscore() {\n    assert!(validate_profile_name(\"my_profile\").is_ok());\n}\n\n#[test]\nfn validate_profile_name_rejects_empty() {\n    let err = validate_profile_name(\"\").unwrap_err();\n    assert!(err.to_string().contains(\"empty\"));\n}\n\n#[test]\nfn validate_profile_name_rejects_too_long() {\n    let long_name = \"a\".repeat(65);\n    let err = validate_profile_name(\u0026long_name).unwrap_err();\n    assert!(err.to_string().contains(\"too long\"));\n}\n\n#[test]\nfn validate_profile_name_rejects_special_chars() {\n    assert!(validate_profile_name(\"my profile\").is_err()); // space\n    assert!(validate_profile_name(\"my/profile\").is_err()); // slash\n    assert!(validate_profile_name(\"my.profile\").is_err()); // dot\n    assert!(validate_profile_name(\"my@profile\").is_err()); // at\n}\n\n#[test]\nfn validate_profile_name_rejects_leading_hyphen() {\n    let err = validate_profile_name(\"-profile\").unwrap_err();\n    assert!(err.to_string().contains(\"cannot start\"));\n}\n\n#[test]\nfn validate_profile_name_rejects_leading_underscore() {\n    let err = validate_profile_name(\"_profile\").unwrap_err();\n    assert!(err.to_string().contains(\"cannot start\"));\n}\n\n#[test]\nfn validate_profile_name_accepts_max_length() {\n    let name = \"a\".repeat(64);\n    assert!(validate_profile_name(\u0026name).is_ok());\n}\n```\n\n## Location\n\nAdd to `src/main.rs` in the `#[cfg(test)] mod tests` section.\n\n## Acceptance Criteria\n\n- [ ] All test cases above pass\n- [ ] Tests are properly documented\n- [ ] Edge cases covered (boundary values for length)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:17:33.749474-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:17:33.749474-05:00"}
{"id":"savant_elite_rust-l7z","title":"EPIC: UX Improvements Phase 2 - Power User Features","description":"# Purpose\n\nThis epic tracks the second wave of user experience improvements, focused on power user workflows and operational maturity.\n\nThese features build on Phase 1 (Core Usability) and address more advanced needs:\n- Multiple configuration management\n- System diagnostics\n- Operational flexibility\n- Data portability\n\n# Background\n\nPhase 1 covers the foundational UX features:\n- Shell completions (discoverability)\n- Key listing (documentation)\n- Presets (quick start)\n- JSON output (scripting)\n- Verbose mode (troubleshooting)\n\nPhase 2 addresses what users need after basic fluency:\n- Config profiles for different contexts\n- Diagnostics for permission issues\n- Flexible timeouts\n- Config validation and portability\n\n# Scope\n\nThis epic covers 5 advanced features:\n\n1. **Config profiles** - Save/load named configurations\n2. **Permission checker** - `savant doctor` for macOS diagnostics  \n3. **Timeout configuration** - `--timeout` flag for hardware operations\n4. **Config validation** - `savant config check` command\n5. **Config backup/history** - Automatic backups before changes\n\n# Relationship to Phase 1\n\nPhase 2 features can be implemented independently of Phase 1, but users will benefit most if Phase 1 is complete first. The dependency is:\n\n- Phase 1 → Phase 2 (soft dependency: better UX if done in order)\n\n# Success Criteria\n\n- Users can maintain multiple configurations easily\n- Permission issues are diagnosable without googling\n- Hardware timing variations are accommodated\n- Config files can be validated before use\n- Accidental config loss is prevented\n\n# Testing Strategy\n\nEach feature includes:\n- Unit tests for new logic\n- Integration tests for CLI behavior\n- Documentation updates\n- Manual verification scripts where appropriate","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-26T13:18:51.471971-05:00","created_by":"jemanuel","updated_at":"2026-01-26T13:18:51.471971-05:00","dependencies":[{"issue_id":"savant_elite_rust-l7z","depends_on_id":"savant_elite_rust-gge","type":"blocks","created_at":"2026-01-26T13:18:55.945324-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-l7z","depends_on_id":"savant_elite_rust-gge","type":"relates-to","created_at":"2026-01-26T13:18:55.945324-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-l87","title":"E2E test script: preset workflows","description":"# E2E test script: preset workflows\n\n## What\n\nCreate E2E shell script that tests all preset-related workflows.\n\n## Script: tests/e2e/test_presets.sh\n\n```bash\n#!/bin/bash\nset -e\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" \u0026\u0026 pwd)\"\nsource \"$SCRIPT_DIR/lib/logging.sh\"\n\nSAVANT=${SAVANT:-savant}\n\n# Test: List all presets\ntest_start \"List presets\"\noutput=$(log_cmd $SAVANT preset --list)\nfor preset in copy-paste undo-redo browser zoom; do\n    if echo \"$output\" | grep -q \"$preset\"; then\n        log_pass \"Found preset: $preset\"\n    else\n        test_end fail \"Missing preset: $preset\"\n        exit 1\n    fi\ndone\ntest_end pass \"All presets listed\"\n\n# Test: List presets JSON\ntest_start \"List presets JSON format\"\noutput=$(log_cmd $SAVANT --json preset --list)\nif echo \"$output\" | jq -e '.presets | length \u003e 0' \u003e /dev/null 2\u003e\u00261; then\n    test_end pass \"JSON preset list is valid\"\nelse\n    test_end fail \"JSON preset list invalid\"\n    exit 1\nfi\n\n# Test: Show each preset\nfor preset in copy-paste undo-redo browser zoom; do\n    test_start \"Show preset: $preset\"\n    output=$(log_cmd $SAVANT preset --show \"$preset\")\n    if echo \"$output\" | grep -qi \"left\\|middle\\|right\"; then\n        test_end pass \"Preset $preset shows pedal config\"\n    else\n        test_end fail \"Preset $preset missing pedal info\"\n        exit 1\n    fi\ndone\n\n# Test: Show preset JSON\ntest_start \"Show preset JSON format\"\noutput=$(log_cmd $SAVANT --json preset --show copy-paste)\nif echo \"$output\" | jq -e '.left and .middle and .right' \u003e /dev/null 2\u003e\u00261; then\n    test_end pass \"JSON preset show is valid\"\nelse\n    test_end fail \"JSON preset show invalid\"\n    exit 1\nfi\n\n# Test: Dry-run preset\ntest_start \"Preset dry-run mode\"\noutput=$(log_cmd $SAVANT preset copy-paste --dry-run)\nif echo \"$output\" | grep -qi \"preview\\|dry.run\\|would\"; then\n    test_end pass \"Dry-run shows preview\"\nelse\n    # Dry-run without device shows config but may not say \"preview\"\n    if echo \"$output\" | grep -qi \"cmd+c\"; then\n        test_end pass \"Dry-run shows configuration\"\n    else\n        test_end fail \"Dry-run output unclear\"\n        exit 1\n    fi\nfi\n\n# Test: Unknown preset rejected\ntest_start \"Unknown preset rejected\"\nif $SAVANT preset nonexistent 2\u003e\u00261 | grep -qi \"not found\\|unknown\\|invalid\"; then\n    test_end pass \"Unknown preset rejected\"\nelse\n    test_end fail \"Unknown preset not properly rejected\"\n    exit 1\nfi\n\nlog_pass \"All preset tests passed\"\n```\n\n## Dependencies\n\n- savant_elite_rust-1w8 (E2E infrastructure)\n- jq for JSON validation\n\n## Acceptance Criteria\n\n- [ ] All preset names found in list\n- [ ] JSON output validates with jq\n- [ ] Show displays pedal configuration\n- [ ] Dry-run mode works\n- [ ] Unknown presets rejected","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:20:25.198019-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:20:25.198019-05:00","dependencies":[{"issue_id":"savant_elite_rust-l87","depends_on_id":"savant_elite_rust-1w8","type":"blocks","created_at":"2026-01-27T15:23:17.303749-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-l87","depends_on_id":"savant_elite_rust-54y","type":"blocks","created_at":"2026-01-27T15:23:18.274-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-liu","title":"Multi-pass bug hunt: harden program + scripts","description":"Audit + fix small issues found by UBS/shellcheck: remove a non-test unwrap in program path; make e2e_config.sh shellcheck-clean.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T00:22:52.079127-05:00","created_by":"jemanuel","updated_at":"2026-01-26T00:23:17.19368-05:00","closed_at":"2026-01-26T00:23:17.19368-05:00","close_reason":"Implemented fixes and re-ran fmt/test/clippy/shellcheck/ubs."}
{"id":"savant_elite_rust-o0s","title":"BEAD-108: Unit tests for modifier parsing coverage","description":"# What / why\n\nModifiers are the hardest part of key-action parsing because:\n- users type many aliases (`cmd`, `command`, `gui`, `meta`, `super`)\n- modifier order shouldn’t matter\n- duplicates shouldn’t change behavior\n- casing varies\n\nIf modifier parsing is wrong, the device is programmed successfully but emits incorrect shortcuts.\n\nThis bead adds comprehensive tests to lock in expected modifier behavior.\n\n# Scope\n\nUnit tests should cover:\n\nAliases:\n- GUI/Cmd: `cmd`, `command`, `gui`, `meta`, `super`\n- Ctrl: `ctrl`, `control`\n- Alt/Option: `alt`, `option`, `opt`\n- Shift: `shift`\n\nCombinatorics / robustness:\n- all four modifiers combined\n- order independence (`cmd+ctrl+a` == `ctrl+cmd+a`)\n- duplicate modifiers are idempotent (`cmd+cmd+a`)\n- case-insensitivity (`CMD+a` == `cmd+a`)\n\nAlso valuable:\n- combinations with function keys / special keys / arrows / punctuation to ensure the “last token is key” rule is stable across key families.\n\n# Test design\n\nPrefer table-driven loops for combinations to keep tests concise but exhaustive.\n\n# Acceptance criteria\n\n- All supported aliases map to the intended HID modifier bits.\n- Parsing is order-independent and case-insensitive.\n- Duplicate modifiers do not change the result.\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:34:38.88079-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:59.937858-05:00","closed_at":"2026-01-25T20:38:59.422782-05:00","close_reason":"Added comprehensive unit tests for modifier parsing: all GUI aliases (cmd/command/gui/meta/super), all CTRL aliases (ctrl/control), all ALT aliases (alt/option/opt), shift, mixed alias combinations, 2-modifier and 3-modifier combinations, modifiers with function keys, special keys, arrow keys, punctuation, and case variations. Total: 8 new test functions covering 77+ test cases.","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-o0s","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.758245-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-p3i","title":"Integration tests for preset configurations","description":"# What / Why\n\nPreset configurations need automated testing to ensure:\n- All built-in presets are valid\n- Preset application works correctly\n- Invalid preset names are rejected\n\n# Scope\n\n## Test cases\n\n1. **List presets succeeds**\n   - `savant preset --list` exits 0\n   - Output contains preset names\n\n2. **Show preset succeeds**\n   - `savant preset copy-paste --show` exits 0\n   - Output contains expected keys\n\n3. **Preset dry-run succeeds**\n   - `savant preset copy-paste --dry-run` exits 0\n   - Does not require hardware\n\n4. **Invalid preset rejected**\n   - `savant preset nonexistent` fails with helpful error\n\n5. **Preset keys are valid**\n   - Each preset's key combinations are parseable\n\n## Implementation\n\n```rust\n#[test]\nfn cli_preset_list() {\n    let output = savant_cmd()\n        .args([\"preset\", \"--list\"])\n        .output()\n        .expect(\"failed to run\");\n    assert!(output.status.success());\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    assert!(stdout.contains(\"copy-paste\"));\n}\n\n#[test]\nfn cli_preset_show() {\n    let output = savant_cmd()\n        .args([\"preset\", \"copy-paste\", \"--show\"])\n        .output()\n        .expect(\"failed to run\");\n    assert!(output.status.success());\n}\n\n#[test]\nfn cli_preset_dry_run() {\n    let output = savant_cmd()\n        .args([\"preset\", \"copy-paste\", \"--dry-run\"])\n        .output()\n        .expect(\"failed to run\");\n    assert!(output.status.success());\n}\n\n#[test]\nfn cli_preset_invalid() {\n    let output = savant_cmd()\n        .args([\"preset\", \"nonexistent\"])\n        .output()\n        .expect(\"failed to run\");\n    assert!(!output.status.success());\n}\n```\n\n# Acceptance Criteria\n\n- [ ] Tests verify preset listing\n- [ ] Tests verify preset details\n- [ ] Tests verify dry-run mode\n- [ ] Tests verify error handling\n- [ ] CI runs these tests\n\n# Dependencies\n\n- Validates: preset configurations feature","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T13:22:20.373234-05:00","created_by":"jemanuel","updated_at":"2026-01-27T01:52:12.529212-05:00","closed_at":"2026-01-27T01:52:12.529212-05:00","close_reason":"Added 8 integration tests for preset command","dependencies":[{"issue_id":"savant_elite_rust-p3i","depends_on_id":"savant_elite_rust-dz9","type":"blocks","created_at":"2026-01-26T13:22:25.907249-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-prb","title":"Integration tests for config profiles feature","description":"# What / Why\n\nConfig profiles need automated testing to ensure:\n- Profile save/load works correctly\n- Profile names are validated\n- Multiple profiles can coexist\n- Profile switching works\n\n# Scope\n\n## Test cases\n\n1. **Profile save**\n   - `savant profile save myprofile` creates profile\n   - Profile file exists in correct location\n\n2. **Profile load**\n   - `savant profile load myprofile` loads profile\n   - Loaded values match saved values\n\n3. **Profile list**\n   - `savant profile list` shows saved profiles\n\n4. **Profile delete**\n   - `savant profile delete myprofile` removes profile\n\n# Acceptance Criteria\n\n- [ ] Tests verify profile save creates file\n- [ ] Tests verify profile load restores config\n- [ ] Tests verify profile list shows available profiles\n- [ ] CI runs these tests","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T14:00:00-05:00","created_by":"jemanuel","updated_at":"2026-01-27T12:05:13.130801-05:00","closed_at":"2026-01-27T12:05:13.130801-05:00","close_reason":"Added 12 integration tests for config profiles","dependencies":[{"issue_id":"savant_elite_rust-prb","depends_on_id":"savant_elite_rust-ewe","type":"blocks","created_at":"2026-01-26T14:00:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-prn","title":"Add JSON output mode for info and status commands","description":"# What / Why\n\nPower users want to script and automate. Currently, the only output format is human-readable terminal output with ANSI colors and box-drawing characters.\n\nJSON output enables:\n- **Scripting**: `savant info --json | jq '.mode'`\n- **Integration**: Other tools can read savant state\n- **Monitoring**: Build dashboards or alerts\n- **Testing**: Easier to assert on structured output\n\nThis is a standard CLI pattern (see: `docker inspect`, `kubectl get -o json`, `gh api`).\n\n# Background\n\nThe existing output is optimized for human readability:\n```\n┌──────────────────────────────────────────────────────────┐\n│  ✓ DEVICE DETECTED                                       │\n└──────────────────────────────────────────────────────────┘\n\n╭──────┬────────┬────────┬───────────┬───────────────╮\n│ Mode │ VID    │ PID    │ Interface │ Usage         │\n├──────┼────────┼────────┼───────────┼───────────────┤\n│ PLAY │ 0x05F3 │ 0x030C │ 1         │ 0x0001:0x0002 │\n```\n\nThis is great for humans but impossible to parse reliably with scripts.\n\n# Scope\n\n## Deliverables\n\n1. **Global `--json` flag** - Enable JSON output mode\n2. **JSON for `savant info`** - Device info and config\n3. **JSON for `savant status`** - Device presence and mode\n4. **JSON for `savant keys`** - Key listing (if that feature exists)\n5. **Consistent structure** - All JSON outputs follow same patterns\n\n## Commands that get JSON support\n\n### `savant info --json`\n\n```json\n{\n  \"device\": {\n    \"detected\": true,\n    \"mode\": \"play\",\n    \"vid\": \"0x05F3\",\n    \"pid\": \"0x030C\",\n    \"interfaces\": [\n      {\"number\": 0, \"usage_page\": \"0x0001\", \"usage\": \"0x0006\"},\n      {\"number\": 1, \"usage_page\": \"0x0001\", \"usage\": \"0x0001\"}\n    ],\n    \"path\": \"DevSrvsID:4295017848\"\n  },\n  \"config\": {\n    \"source\": \"file\",\n    \"path\": \"~/.config/savant-elite/pedals.conf\",\n    \"left\": \"cmd+c\",\n    \"middle\": \"cmd+a\", \n    \"right\": \"cmd+v\"\n  }\n}\n```\n\n### `savant status --json`\n\n```json\n{\n  \"device\": {\n    \"detected\": true,\n    \"mode\": \"programming\",\n    \"pid\": \"0x030D\",\n    \"bus\": 1,\n    \"address\": 13\n  },\n  \"ready_to_program\": true\n}\n```\n\n### `savant info --json` (no device)\n\n```json\n{\n  \"device\": {\n    \"detected\": false,\n    \"mode\": null\n  },\n  \"config\": {\n    \"source\": \"file\",\n    \"path\": \"~/.config/savant-elite/pedals.conf\",\n    \"left\": \"cmd+c\",\n    \"middle\": \"cmd+a\",\n    \"right\": \"cmd+v\"\n  }\n}\n```\n\n# Design\n\n## Implementation approach\n\n1. Add `--json` flag to `Cli` struct (global flag)\n2. Create serde-serializable structs for output:\n   ```rust\n   #[derive(Serialize)]\n   struct DeviceInfo {\n       detected: bool,\n       mode: Option\u003cString\u003e,\n       // ...\n   }\n   ```\n3. In each command, check if JSON mode is enabled\n4. If JSON, serialize to stdout; if not, use existing pretty-print\n\n## Considerations\n\n### No color in JSON mode\n\nWhen `--json` is set, also disable ANSI colors. JSON should be:\n- No ANSI escape codes\n- Single line or pretty-printed JSON only\n- Exit code still reflects success/failure\n\n### Exit codes\n\n- 0: Success (device found, operation completed)\n- 1: Device not found (JSON still output with `detected: false`)\n- 2: Error (invalid args, permission denied, etc.)\n\nThis allows scripts to check both exit code AND JSON content.\n\n### Streaming vs buffered\n\nFor `savant info` and `savant status`, output is small enough to buffer and emit at end. No streaming needed.\n\n# Testing\n\n## Automated\n\n- Integration test: `savant info --json` produces valid JSON\n- Integration test: `savant status --json` produces valid JSON\n- Integration test: JSON contains expected fields\n- Integration test: JSON has no ANSI escape codes\n- Unit test: serialization structs are complete\n\n## Manual\n\n- Verify `savant info --json | jq .` works\n- Verify scripting use case: `if [ \"$(savant status --json | jq -r .device.mode)\" = \"programming\" ]; then ...`\n\n# Acceptance Criteria\n\n- [ ] `savant info --json` outputs valid JSON\n- [ ] `savant status --json` outputs valid JSON\n- [ ] JSON output contains no ANSI escape codes\n- [ ] JSON structure is documented (in README or man page)\n- [ ] Exit codes are meaningful (0=success, 1=no device, 2=error)\n- [ ] `--json` flag appears in `--help`\n\n# Dependencies\n\n- Consider: `savant keys --json` should follow same pattern\n\n# Considerations\n\n## Why not YAML/TOML?\n\nJSON is:\n- Universal (every language can parse it)\n- Works with `jq` (ubiquitous)\n- Standard for CLIs (Docker, kubectl, gh)\n\nYAML/TOML could be added later if needed.\n\n## Why global flag vs per-command?\n\nGlobal `--json` is simpler UX:\n- Consistent across all commands\n- One thing to remember\n- Easier to document\n\nAlternative: `--output json` or `-o json` (like kubectl). Could be added for flexibility.\n\n# Estimated Effort\n\nMedium: Requires adding serde dependency, creating output structs, and modifying each command's output path.","status":"closed","priority":2,"issue_type":"feature","assignee":"GrayForge","created_at":"2026-01-26T13:17:59.674683-05:00","created_by":"jemanuel","updated_at":"2026-01-26T22:29:58.097967-05:00","closed_at":"2026-01-26T22:29:58.097967-05:00","close_reason":"Implemented --json flag for info and status commands with 5 integration tests"}
{"id":"savant_elite_rust-q83","title":"Integration tests for 'savant doctor' command","description":"# Test bead\n\nAutomated tests for the feature.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel","updated_at":"2026-01-27T12:29:41.824233-05:00","closed_at":"2026-01-27T12:29:41.824233-05:00","close_reason":"Added 6 integration tests for doctor command","dependencies":[{"issue_id":"savant_elite_rust-q83","depends_on_id":"savant_elite_rust-b09","type":"blocks","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-qvt","title":"BEAD-301: Add test dependencies to Cargo.toml","description":"# What / why\n\nWe want two automated test layers:\n- integration tests via `assert_cmd`\n- unit tests that use temporary directories/files safely\n\nSo we need a small set of dev-dependencies.\n\n# Scope\n\nAdd to `Cargo.toml` under `[dev-dependencies]`:\n- `assert_cmd` (CLI integration testing)\n- `predicates` (assertions on stdout/stderr)\n- `tempfile` (safe filesystem isolation)\n\n# Acceptance criteria\n\n- `cargo test` builds and runs with these dev-deps.\n- No runtime dependency impact for release builds.\n\n","status":"closed","priority":1,"issue_type":"task","assignee":"claude-opus","estimated_minutes":5,"created_at":"2026-01-25T18:53:12.281581-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:52:00.944795-05:00","closed_at":"2026-01-25T19:33:56.672035-05:00","close_reason":"Added dev-dependencies: assert_cmd 2, predicates 3, tempfile 3","labels":["infra","phase5"],"dependencies":[{"issue_id":"savant_elite_rust-qvt","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.094688-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-r2n","title":"Integration tests for automatic config backup feature","description":"# What / Why\n\nAutomatic config backup needs automated testing to ensure:\n- Backups are created before changes\n- Backup naming is correct\n- Old backups are retained/rotated correctly\n\n# Scope\n\n## Test cases\n\n1. **Backup created on change**\n   - Programming creates backup of existing config\n   - Backup file exists with timestamp\n\n2. **Backup naming**\n   - Backup follows naming convention (e.g., pedals.conf.bak.20260126-140000)\n   - Multiple backups can coexist\n\n3. **Backup content**\n   - Backup contains previous config content\n   - Backup is valid config file\n\n# Acceptance Criteria\n\n- [ ] Tests verify backups created before changes\n- [ ] Tests verify backup naming convention\n- [ ] Tests verify backup content matches previous config\n- [ ] CI runs these tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T14:00:00-05:00","created_by":"jemanuel","updated_at":"2026-01-26T14:00:00-05:00","dependencies":[{"issue_id":"savant_elite_rust-r2n","depends_on_id":"savant_elite_rust-1hk","type":"blocks","created_at":"2026-01-26T14:00:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-rav","title":"Add verbose/debug mode for troubleshooting","description":"# What / Why\n\nWhen something goes wrong, users have no visibility into what's happening. They see:\n```\nError: Failed to program pedal\n```\n\nBut they need to know:\n- What USB command was sent?\n- What response was received?\n- Where exactly did it fail?\n\nVerbose mode provides this visibility, essential for:\n- **Troubleshooting firmware variations** - Different device versions may behave differently\n- **Permission debugging** - Is the failure in USB access or HID protocol?\n- **Bug reports** - Users can provide detailed logs\n- **Development** - Developers can see protocol details\n\n# Background\n\nThe codebase already has some debug output via `println!` in certain paths, but it's inconsistent and not controllable by the user.\n\nOther CLIs use:\n- `-v` / `--verbose` for moderate detail\n- `-vv` for more detail\n- `RUST_LOG=debug` for internal logging\n\nWe should support at least the `-v/--verbose` pattern.\n\n# Scope\n\n## Deliverables\n\n1. **`-v/--verbose` global flag** - Enable verbose output\n2. **USB command logging** - Show HID commands being sent\n3. **Response logging** - Show raw bytes received\n4. **Timing info** - How long operations took\n5. **Clean separation** - Verbose output to stderr, normal output to stdout\n\n## What gets logged in verbose mode\n\n### Device enumeration\n```\n[verbose] Enumerating HID devices...\n[verbose] Found device: VID=0x05F3 PID=0x030C path=DevSrvsID:4295017848\n[verbose] Found device: VID=0x05F3 PID=0x030C path=DevSrvsID:4295017849\n[verbose] Matched Savant Elite (PLAY mode) on interface 0\n```\n\n### Programming operations\n```\n[verbose] Claiming USB interface 0...\n[verbose] Interface claimed successfully\n[verbose] Sending SET_KEY_MACRO for pedal 0:\n[verbose]   Request: bmRequestType=0x21 bRequest=0x09 wValue=0x0200 wIndex=0\n[verbose]   Data: [00, CC, 00, 08, 06, 00, 00, ...] (36 bytes)\n[verbose]   Response: 36 bytes written in 12ms\n[verbose] Sending GET_KEY_MACRO for verification:\n[verbose]   Request: bmRequestType=0xA1 bRequest=0x01 wValue=0x0300 wIndex=0\n[verbose]   Response: [00, CD, 00, 08, 06, 00, ...] (36 bytes)\n[verbose]   Verification: MATCH (mod=0x08, key=0x06)\n```\n\n### Config operations\n```\n[verbose] Loading config from: /Users/me/.config/savant-elite/pedals.conf\n[verbose] Config loaded: left=cmd+c, middle=cmd+a, right=cmd+v\n[verbose] Saving config to: /Users/me/.config/savant-elite/pedals.conf\n[verbose] Config saved successfully\n```\n\n### Monitor mode\n```\n[verbose] Opening HID device for monitoring...\n[verbose] Device opened: VID=0x05F3 PID=0x030C\n[verbose] Read buffer: 8 bytes\n[verbose] Raw report: [00, 00, 06, 00, 00, 00, 00, 00]\n[verbose] Decoded: key=0x06 (c) modifiers=0x00\n```\n\n# Design\n\n## Implementation approach\n\n1. Add `-v/--verbose` flag to `Cli` struct (global)\n2. Store verbose flag in `SavantElite` struct\n3. Create helper method: `fn verbose(\u0026self, msg: \u0026str)` that prints to stderr if enabled\n4. Add verbose calls at key points in the code\n\n## Output formatting\n\n```rust\nimpl SavantElite {\n    fn verbose(\u0026self, msg: \u0026str) {\n        if self.verbose {\n            eprintln!(\"[verbose] {}\", msg);\n        }\n    }\n    \n    fn verbose_hex(\u0026self, label: \u0026str, data: \u0026[u8]) {\n        if self.verbose {\n            let hex: Vec\u003cString\u003e = data.iter().map(|b| format!(\"{:02X}\", b)).collect();\n            eprintln!(\"[verbose] {}: [{}]\", label, hex.join(\", \"));\n        }\n    }\n}\n```\n\n## Stderr vs stdout\n\n- Normal output → stdout (for piping)\n- Verbose output → stderr (doesn't pollute pipes)\n- Errors → stderr\n\nThis means `savant info -v 2\u003e/dev/null` still works normally.\n\n# Testing\n\n## Automated\n\n- Integration test: `-v` flag is accepted\n- Integration test: verbose output goes to stderr\n- Integration test: normal output still goes to stdout\n- Integration test: verbose output contains expected markers\n\n## Manual\n\n- Run `savant info -v` and verify output is helpful\n- Run `savant program -v --dry-run` and verify command details shown\n- Verify `savant info -v 2\u003e/dev/null` produces clean stdout\n\n# Acceptance Criteria\n\n- [ ] `-v/--verbose` flag enables detailed output\n- [ ] Verbose output includes USB command details (request type, data)\n- [ ] Verbose output includes response data (hex bytes)\n- [ ] Verbose output goes to stderr\n- [ ] Normal output unaffected when verbose enabled\n- [ ] `--help` documents verbose flag\n\n# Dependencies\n\nNone - this is independent and foundational.\n\n# Considerations\n\n## Multiple verbosity levels?\n\nSome CLIs support `-v`, `-vv`, `-vvv` for increasing detail. For now, single level is sufficient. Can be extended later if needed.\n\n## Environment variable?\n\nCould also support `SAVANT_VERBOSE=1` for persistent verbose mode. Nice to have but not essential.\n\n## Log file?\n\nCould support `--log \u003cfile\u003e` to write verbose output to file. Useful for bug reports. Stretch goal.\n\n# Estimated Effort\n\nMedium: Requires touching multiple code paths to add verbose output, but each addition is simple.","status":"closed","priority":2,"issue_type":"feature","assignee":"GrayForge","created_at":"2026-01-26T13:18:32.41846-05:00","created_by":"jemanuel","updated_at":"2026-01-26T21:11:42.873759-05:00","closed_at":"2026-01-26T21:11:42.873759-05:00","close_reason":"Implemented -v/--verbose flag with verbose output for HID enumeration, key parsing, USB operations, config loading, and monitor mode. All 94 tests pass (47 unit + 47 integration)."}
{"id":"savant_elite_rust-skt","title":"CI/Release: fix invalid macOS Intel runner label","description":"GitHub Actions workflows used 'macos-15-intel' (not a valid runner label). Switch Intel builds to macos-13 so CI and releases can actually run x86_64 builds.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-26T02:35:52.867967-05:00","created_by":"jemanuel","updated_at":"2026-01-26T02:36:01.508517-05:00","closed_at":"2026-01-26T02:36:01.508517-05:00","close_reason":"Updated .github/workflows/{ci,release}.yml to use macos-13 for x86_64 builds and re-ran local test/clippy/shellcheck."}
{"id":"savant_elite_rust-wyy","title":"BEAD-302: Add tests/ README and script scaffolding","description":"# What / why\n\nWe want the `tests/` directory to be self-explanatory:\n- what automated tests exist\n- what manual scripts exist\n- what prerequisites are required (hardware, permissions)\n\nWithout documentation, future maintenance is slow and error-prone.\n\n# Scope\n\n- Add `tests/README.md` explaining:\n  - unit vs integration tests\n  - manual scripts and when to run them\n  - macOS-specific requirements (Input Monitoring, sudo)\n\n- Ensure manual scripts exist under `tests/`:\n  - `tests/e2e_hardware_sim.sh` (BEAD-202)\n  - `tests/e2e_config.sh` (BEAD-203)\n\n- Ensure generated logs go to `tests/logs/` and are ignored by git.\n\n# Acceptance criteria\n\n- `tests/README.md` exists and points at the correct scripts.\n- `tests/logs/` is gitignored.\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:44:42.541732-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:52:09.820864-05:00","closed_at":"2026-01-25T20:55:33.491697-05:00","close_reason":"Added tests/README.md and checked in manual E2E scripts under tests/; ignored generated logs via /tests/logs/ in .gitignore.","labels":["infra","phase5","test"],"dependencies":[{"issue_id":"savant_elite_rust-wyy","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.54991-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-wyy","depends_on_id":"savant_elite_rust-qvt","type":"blocks","created_at":"2026-01-25T23:54:03.46892-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-xc1","title":"BEAD-103: Unit tests for PedalConfig newline handling","description":"# What / why\n\nThis bead adds unit tests for the security/robustness fix in BEAD-002.\n\nWe want to guarantee that config values written to disk cannot contain embedded newlines or carriage returns, because the config file is line-based.\n\n# Scope\n\nAdd tests that assert:\n- `PedalConfig::save()` rejects values containing `\\n`\n- `PedalConfig::save()` rejects values containing `\\r`\n\n# Test design / safety\n\nImportant: these tests should not modify real user config.\n\nThe chosen pattern is safe because:\n- validation happens during serialization **before** any filesystem write\n- the test inputs are intentionally invalid (contain `\\n`/`\\r`), so `save()` errors out early\n\n# Acceptance criteria\n\n- Tests fail if newline validation is removed or weakened.\n- Error message mentions “newline” so the failure is understandable.\n\n# Related beads\n\n- Validates: BEAD-002\n\n","status":"closed","priority":1,"issue_type":"task","estimated_minutes":20,"created_at":"2026-01-25T18:52:49.282022-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:09.378619-05:00","closed_at":"2026-01-25T18:55:14.010658-05:00","close_reason":"Tests added in same commit as BEAD-002 fix","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-xc1","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.298165-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-xc1","depends_on_id":"savant_elite_rust-bq1","type":"validates","created_at":"2026-01-25T23:54:02.953419-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-xoh","title":"Add 'savant config check' for config file validation","description":"# What / Why\n\nUsers might hand-edit config files or receive them from others. A validation command ensures the config is correct before attempting to use it.\n\nCurrently, invalid configs are only detected when you try to program or view info. A dedicated `check` command provides:\n- **Pre-flight validation** - Catch errors before programming\n- **Config debugging** - See exactly what the tool will interpret\n- **Shareable configs** - Verify received configs are valid\n\n# Background\n\nConfig file format:\n```\nleft=cmd+c\nmiddle=cmd+a\nright=cmd+v\n```\n\nThings that can go wrong:\n- Missing required keys (left, middle, or right)\n- Invalid key names (`left=cmd+foo`)\n- Invalid modifier names (`left=super+c` should work, but `left=hyper+c` won't)\n- Malformed syntax (`left cmd+c` missing `=`)\n- Invalid characters (newlines in values, etc.)\n\n# Scope\n\n## Deliverables\n\n1. **`savant config check`** - Validate current config file\n2. **`savant config check \u003cfile\u003e`** - Validate arbitrary config file\n3. **Detailed error messages** - Show exactly what's wrong\n4. **Success output** - Show parsed configuration when valid\n\n## CLI interface\n\n```bash\n# Check default config file\nsavant config check\n\n# Check arbitrary file\nsavant config check /path/to/pedals.conf\n\n# Output on success:\n✓ Configuration valid\n\n  Left:   cmd+c   (modifier: 0x08, key: 0x06)\n  Middle: cmd+a   (modifier: 0x08, key: 0x04)\n  Right:  cmd+v   (modifier: 0x08, key: 0x19)\n\n# Output on failure:\n✗ Configuration invalid\n\n  Line 1: left=cmd+foo\n          Error: Unknown key: \"foo\"\n          \n  Valid keys: a-z, 0-9, f1-f12, enter, space, tab, esc, ...\n  Run 'savant keys' for complete list.\n```\n\n## Validation checks\n\n1. **File exists** - Clear message if missing\n2. **File readable** - Permission check\n3. **Required keys present** - left, middle, right all required\n4. **Key action syntax** - Each value is parseable\n5. **Modifier names valid** - All modifiers recognized\n6. **Key names valid** - All keys recognized\n7. **No injection chars** - No newlines/carriage returns in values\n\n## Output levels\n\n### Minimal (default)\n```\n✓ Configuration valid\n```\n\n### Verbose (`-v`)\n```\n✓ Configuration valid\n\n  File: ~/.config/savant-elite/pedals.conf\n  \n  Left:   cmd+c\n          Parsed: modifier=GUI (0x08), key=C (0x06)\n  Middle: cmd+a\n          Parsed: modifier=GUI (0x08), key=A (0x04)\n  Right:  cmd+v\n          Parsed: modifier=GUI (0x08), key=V (0x19)\n```\n\n# Design\n\n## Implementation approach\n\n1. Add `check` sub-subcommand under `config`\n2. Load and parse config file\n3. Validate each key action\n4. Collect all errors (don't stop at first)\n5. Report success or all errors\n\n## Error collection\n\nDon't stop at first error - show all problems:\n```\n✗ Configuration invalid\n\n  Line 1: left=cmd+foo\n          Error: Unknown key: \"foo\"\n  \n  Line 3: right=hyper+c\n          Error: Unknown modifier: \"hyper\"\n          Did you mean: ctrl, alt, shift, cmd?\n\n2 errors found\n```\n\nThis is more helpful than fixing one error at a time.\n\n# Testing\n\n## Automated\n\n- Integration test: valid config passes\n- Integration test: missing file reported\n- Integration test: invalid key detected\n- Integration test: invalid modifier detected\n- Integration test: missing required key detected\n- Unit test: validation logic\n\n## Manual\n\n- Create intentionally broken config, verify errors reported\n- Fix errors one by one, verify decreasing error count\n\n# Acceptance Criteria\n\n- [ ] `savant config check` validates default config\n- [ ] `savant config check \u003cfile\u003e` validates arbitrary file\n- [ ] Missing keys reported with clear message\n- [ ] Invalid key names reported with suggestions\n- [ ] Invalid modifier names reported with suggestions\n- [ ] All errors shown (not just first one)\n- [ ] Success shows parsed configuration\n- [ ] Exit code: 0=valid, 1=invalid\n\n# Dependencies\n\n- Builds on: `savant keys` (can reference for valid key list)\n- Works with: verbose mode, JSON output\n\n# Considerations\n\n## Strict vs lenient?\n\nCurrently, config loading is lenient (ignores unknown keys). Validation should be strict:\n- Unknown keys: warning (future compatibility)\n- Missing required keys: error\n- Invalid values: error\n\n## JSON output?\n\n`savant config check --json` returns:\n```json\n{\n  \"valid\": false,\n  \"errors\": [\n    {\"line\": 1, \"field\": \"left\", \"error\": \"Unknown key: foo\"}\n  ]\n}\n```\n\nUseful for tooling integration.\n\n# Estimated Effort\n\nSmall: Reuses existing parsing, mainly new output formatting.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-26T13:20:59.867702-05:00","created_by":"jemanuel","updated_at":"2026-01-27T14:29:09.398276-05:00","closed_at":"2026-01-27T14:29:09.398276-05:00","close_reason":"Implemented 'savant config check' command with 7 integration tests"}
{"id":"savant_elite_rust-ycp","title":"E2E test script: help and version commands","description":"# E2E test script: help and version commands\n\n## What\n\nCreate E2E shell script that tests all help and version outputs.\n\n## Script: tests/e2e/test_help_version.sh\n\n```bash\n#!/bin/bash\nset -e\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" \u0026\u0026 pwd)\"\nsource \"$SCRIPT_DIR/lib/logging.sh\"\n\nSAVANT=${SAVANT:-savant}\n\n# Test: Main help\ntest_start \"Main --help output\"\noutput=$(log_cmd $SAVANT --help)\nif echo \"$output\" | grep -q \"Kinesis Savant Elite\"; then\n    test_end pass \"Main help shows description\"\nelse\n    test_end fail \"Main help missing description\"\n    exit 1\nfi\n\n# Test: Version\ntest_start \"Version output\"\noutput=$(log_cmd $SAVANT --version)\nif echo \"$output\" | grep -qE \"savant [0-9]+\\.[0-9]+\"; then\n    test_end pass \"Version shows semver\"\nelse\n    test_end fail \"Version format incorrect\"\n    exit 1\nfi\n\n# Test: All subcommand help\nfor cmd in program monitor status info probe keys preset config doctor completions; do\n    test_start \"Subcommand help: $cmd\"\n    if log_cmd $SAVANT $cmd --help \u003e /dev/null 2\u003e\u00261; then\n        test_end pass \"$cmd --help succeeds\"\n    else\n        test_end fail \"$cmd --help failed\"\n        exit 1\n    fi\ndone\n\n# Test: Config subcommand help\nfor subcmd in save load list show delete check; do\n    test_start \"Config subcommand help: $subcmd\"\n    if log_cmd $SAVANT config $subcmd --help \u003e /dev/null 2\u003e\u00261; then\n        test_end pass \"config $subcmd --help succeeds\"\n    else\n        test_end fail \"config $subcmd --help failed\"\n        exit 1\n    fi\ndone\n\nlog_pass \"All help/version tests passed\"\n```\n\n## Dependencies\n\n- savant_elite_rust-1w8 (E2E infrastructure)\n\n## Acceptance Criteria\n\n- [ ] All subcommands have working --help\n- [ ] Version format is correct\n- [ ] Script exits with proper codes\n- [ ] Detailed logging to file","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T15:20:01.173538-05:00","created_by":"jemanuel","updated_at":"2026-01-27T15:20:01.173538-05:00","dependencies":[{"issue_id":"savant_elite_rust-ycp","depends_on_id":"savant_elite_rust-1w8","type":"blocks","created_at":"2026-01-27T15:23:17.234532-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-ycp","depends_on_id":"savant_elite_rust-54y","type":"blocks","created_at":"2026-01-27T15:23:18.205822-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-yma","title":"BEAD-106: Unit tests for PedalConfig save/load roundtrip","description":"# What / why\n\n`PedalConfig` is the on-disk record of the last programmed pedal mappings.\n\nEven though it’s simple, it needs to be robust because:\n- users may hand-edit the file\n- earlier versions might write slightly different whitespace\n- we may add new keys later (forward compatibility)\n\nThis bead adds unit tests that lock in the intended config semantics:\n- roundtrip correctness\n- tolerant parsing (whitespace, unknown keys)\n- safe behavior when the file is missing or incomplete\n\n# Scope\n\nAdd tests for:\n- **Roundtrip**: save a config, read it back, values match.\n- **Missing file**: `load_from()` returns `None` (not error).\n- **Partial file**: missing any of `left/middle/right` returns `None`.\n- **Whitespace**: keys/values are trimmed; blank lines ignored; unknown keys ignored.\n\n# Test design\n\nUse `tempfile::tempdir()` and explicit `save_to(path)` / `load_from(path)` to avoid touching real user config.\n\nParsing rules under test:\n- `left`, `middle`, `right` must all be present and non-empty.\n- extra lines are ignored (forward compatibility).\n\n# Acceptance criteria\n\n- Tests are deterministic and do not require hardware.\n- Tests pass on clean machines with no existing config.\n\n# Related beads\n\n- Supports: BEAD-006 (preserving user intent relies on config persistence)\n\n","status":"closed","priority":1,"issue_type":"task","assignee":"claude-opus-4.5","estimated_minutes":45,"created_at":"2026-01-25T18:52:49.40373-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:50:37.883752-05:00","closed_at":"2026-01-25T19:44:06.762435-05:00","close_reason":"Closed","labels":["phase3","test","unit-test"],"dependencies":[{"issue_id":"savant_elite_rust-yma","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.247019-05:00","created_by":"jemanuel"}],"comments":[{"id":3,"issue_id":"savant_elite_rust-yma","author":"jemanuel","text":"Claimed by Codex. Adding PedalConfig save/load roundtrip + whitespace/partial/missing-file unit tests (no real user config writes); will run cargo test and sync.","created_at":"2026-01-26T00:37:02Z"},{"id":4,"issue_id":"savant_elite_rust-yma","author":"jemanuel","text":"Follow-up: updated PedalConfig persistence unit tests to use tempfile::tempdir (auto-cleaning) instead of creating ad-hoc temp directories.","created_at":"2026-01-26T01:07:54Z"}]}
{"id":"savant_elite_rust-yoc","title":"Integration tests for 'savant doctor' command","description":"# What / Why\n\nThe doctor command needs automated testing to ensure:\n- Command runs without error\n- Output is informative\n- Checks are performed correctly\n- JSON output works\n\n# Scope\n\n## Test cases\n\n1. **Command runs**\n   - `savant doctor` exits successfully\n   - `savant doctor --json` produces valid JSON\n\n2. **Permission checks**\n   - Doctor reports USB permission status\n   - Doctor reports Input Monitoring status (macOS)\n\n3. **Environment checks**\n   - Checks macOS version\n   - Checks IOKit availability\n\n# Acceptance Criteria\n\n- [ ] Tests verify doctor command runs\n- [ ] Tests verify JSON output is valid\n- [ ] Tests verify expected checks are performed\n- [ ] CI runs these tests","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T14:00:00-05:00","created_by":"jemanuel","updated_at":"2026-01-27T12:29:41.829762-05:00","closed_at":"2026-01-27T12:29:41.829762-05:00","close_reason":"Added 6 integration tests for doctor command","dependencies":[{"issue_id":"savant_elite_rust-yoc","depends_on_id":"savant_elite_rust-b09","type":"blocks","created_at":"2026-01-26T14:00:00-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-yyo","title":"BEAD-201: CLI argument validation E2E tests","description":"# What / why\n\nWe need strong coverage that the CLI rejects invalid inputs **before** it touches hardware.\n\nConstraints:\n- CI cannot rely on physical Savant Elite hardware.\n- Many validation rules are pure string parsing / clap validation.\n\nSo we use integration tests (`assert_cmd`) that execute the compiled `savant` binary and assert:\n- exit status\n- stderr/stdout contains helpful messages\n\nThis is the best way to lock in user-facing behavior.\n\n# Scope\n\nIntegration tests should cover (at minimum):\n\n`program` command (no hardware):\n- empty pedal values rejected\n- invalid key names rejected\n- invalid modifier names rejected\n- malformed plus forms rejected (leading/trailing/consecutive/only-plus)\n- valid combinations succeed under `--dry-run`\n\n`raw-cmd` command:\n- invalid hex command rejected\n- invalid hex data rejected\n- odd-length hex rejected\n- negative / too-large interface rejected (clap)\n- data payload too long rejected\n\nGeneral CLI:\n- `--help` and `--version` succeed\n- unknown subcommand rejected\n\n# Test design\n\nKey property: **tests must be hardware-independent**.\n\nTechniques:\n- always pass `--dry-run` for `program` so key parsing is exercised without USB access\n- use `env!(\"CARGO_BIN_EXE_savant\")` (or equivalent) to avoid deprecated `Command::cargo_bin` APIs\n- match error messages by stable substrings (avoid brittle full-string equality)\n\n# Acceptance criteria\n\n- `cargo test` passes on machines with no Savant Elite device connected.\n- Integration tests cover the major invalid-input classes described above.\n- Errors remain actionable (contain “cannot be empty”, “Unknown key”, etc.).\n\n# Related beads\n\n- Covers/validates: BEAD-001, BEAD-004, BEAD-005, BEAD-105\n\n","status":"closed","priority":1,"issue_type":"task","assignee":"claude-opus-4.5","estimated_minutes":120,"created_at":"2026-01-25T18:53:12.222244-05:00","created_by":"jemanuel","updated_at":"2026-01-25T23:51:21.950369-05:00","closed_at":"2026-01-25T19:41:26.396359-05:00","close_reason":"Fixed all E2E tests: 30 tests now passing. Updated tests to match actual error messages and CLI behavior.","labels":["e2e","phase4","test"],"dependencies":[{"issue_id":"savant_elite_rust-yyo","depends_on_id":"savant_elite_rust-1pa","type":"parent-child","created_at":"2026-01-25T23:45:41.147719-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-yyo","depends_on_id":"savant_elite_rust-qvt","type":"blocks","created_at":"2026-01-25T23:54:03.19315-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-yyo","depends_on_id":"savant_elite_rust-4eo","type":"validates","created_at":"2026-01-25T23:54:03.239232-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-yyo","depends_on_id":"savant_elite_rust-6hu","type":"validates","created_at":"2026-01-25T23:54:03.281345-05:00","created_by":"jemanuel"},{"issue_id":"savant_elite_rust-yyo","depends_on_id":"savant_elite_rust-5iu","type":"validates","created_at":"2026-01-25T23:54:03.331196-05:00","created_by":"jemanuel"}]}
{"id":"savant_elite_rust-z3o","title":"Integration tests for configurable timeout feature","description":"# Test bead\n\nAutomated tests for the feature.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel","updated_at":"2026-01-27T12:35:49.446094-05:00","closed_at":"2026-01-27T12:35:49.446094-05:00","close_reason":"Implemented --timeout flag with 100ms-600000ms range, verbose logging, and 8 integration tests","dependencies":[{"issue_id":"savant_elite_rust-z3o","depends_on_id":"savant_elite_rust-gn0","type":"blocks","created_at":"2026-01-26T14:30:00-05:00","created_by":"jemanuel"}]}
